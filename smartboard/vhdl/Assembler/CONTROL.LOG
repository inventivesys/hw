KCPSM3 Assembler log file for program 'control.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
16Jan2007-11:31:32

 Addr Code

 000                           ;KCPSM3 Program - Control of LEDs and LCD display using switches, buttons and rotary
 000                           ;controls on the Spartan-3E Starter Kit.
 000                           ;
 000                           ;
 000                           ;Ken Chapman - Xilinx Ltd
 000                           ;
 000                           ;Version v1.00 - 4th January 2006
 000                           ;
 000                           ;**************************************************************************************
 000                           ;Port definitions
 000                           ;**************************************************************************************
 000                           ;
 000                           ;
 000                           ;
 000                           CONSTANT LED_port, 80               ;8 simple LEDs
 000                           CONSTANT LED0, 01                   ;     LED 0 - bit0
 000                           CONSTANT LED1, 02                   ;         1 - bit1
 000                           CONSTANT LED2, 04                   ;         2 - bit2
 000                           CONSTANT LED3, 08                   ;         3 - bit3
 000                           CONSTANT LED4, 10                   ;         4 - bit4
 000                           CONSTANT LED5, 20                   ;         5 - bit5
 000                           CONSTANT LED6, 40                   ;         6 - bit6
 000                           CONSTANT LED7, 80                   ;         7 - bit7
 000                           ;
 000                           ;
 000                           CONSTANT switch_port, 00            ;Read switches and press buttons
 000                           CONSTANT switch0, 01                ;  Switches      SW0 - bit0
 000                           CONSTANT switch1, 02                ;                SW1 - bit1
 000                           CONSTANT switch2, 04                ;                SW2 - bit2
 000                           CONSTANT switch3, 08                ;                SW3 - bit3
 000                           CONSTANT BTN_east, 10               ;  Buttons      East - bit4
 000                           CONSTANT BTN_south, 20              ;              South - bit5
 000                           CONSTANT BTN_north, 40              ;              North - bit6
 000                           CONSTANT BTN_west, 80               ;               West - bit7
 000                           ;
 000                           ;
 000                           CONSTANT rotary_port, 01            ;Read status of rotary encoder
 000                           CONSTANT rotary_left, 01            ; Direction of last move Left=1 Right=0  - bit0
 000                           CONSTANT rotary_press, 02           ;     Centre press contact (active High) - bit1
 000                           ;
 000                           ;
 000                           ;LCD interface ports
 000                           ;
 000                           ;The master enable signal is not used by the LCD display itself
 000                           ;but may be required to confirm that LCD communication is active.
 000                           ;This is required on the Spartan-3E Starter Kit if the StrataFLASH
 000                           ;is used because it shares the same data pins and conflicts must be avoided.
 000                           ;
 000                           CONSTANT LCD_output_port, 40        ;LCD character module output data and control
 000                           CONSTANT LCD_E, 01                  ;   active High Enable        E - bit0
 000                           CONSTANT LCD_RW, 02                 ;   Read=1 Write=0           RW - bit1
 000                           CONSTANT LCD_RS, 04                 ;   Instruction=0 Data=1     RS - bit2
 000                           CONSTANT LCD_drive, 08              ;   Master enable (active High) - bit3
 000                           CONSTANT LCD_DB4, 10                ;   4-bit              Data DB4 - bit4
 000                           CONSTANT LCD_DB5, 20                ;   interface          Data DB5 - bit5
 000                           CONSTANT LCD_DB6, 40                ;                      Data DB6 - bit6
 000                           CONSTANT LCD_DB7, 80                ;                      Data DB7 - bit7
 000                           ;
 000                           ;
 000                           CONSTANT LCD_input_port, 02         ;LCD character module input data
 000                           CONSTANT LCD_read_spare0, 01        ;    Spare bits               - bit0
 000                           CONSTANT LCD_read_spare1, 02        ;    are zero                 - bit1
 000                           CONSTANT LCD_read_spare2, 04        ;                             - bit2
 000                           CONSTANT LCD_read_spare3, 08        ;                             - bit3
 000                           CONSTANT LCD_read_DB4, 10           ;    4-bit           Data DB4 - bit4
 000                           CONSTANT LCD_read_DB5, 20           ;    interface       Data DB5 - bit5
 000                           CONSTANT LCD_read_DB6, 40           ;                    Data DB6 - bit6
 000                           CONSTANT LCD_read_DB7, 80           ;                    Data DB7 - bit7
 000                           ;
 000                           ;
 000                           ;
 000                           ;**************************************************************************************
 000                           ;Special Register usage
 000                           ;**************************************************************************************
 000                           ;
 000                           ;**************************************************************************************
 000                           ;Scratch Pad Memory Locations
 000                           ;**************************************************************************************
 000                           ;
 000                           CONSTANT rotary_status, 00          ;Status of rotary encoder
 000                           CONSTANT ISR_preserve_s0, 01        ;Preserve s0 contents during ISR
 000                           ;
 000                           CONSTANT LED_pattern, 02            ;LED pattern used in rotation mode
 000                           ;
 000                           CONSTANT mode, 03                   ;control mode 00=switch and button FF=rotary
 000                           ;
 000                           ;
 000                           ;
 000                           ;**************************************************************************************
 000                           ;Useful data constants
 000                           ;**************************************************************************************
 000                           ;
 000                           ;
 000                           ;The main operation of the program uses 1ms delays to set the shift rate
 000                           ;of the LCD display. A 16-bit value determines how many milliseconds
 000                           ;there are between shifts
 000                           ;
 000                           ;Tests indicate that the fastest shift rate that the LCD display supports is
 000                           ;500ms. Faster than this and the display becomes less clear to read.
 000                           ;
 000                           CONSTANT shift_delay_msb, 01        ;delay is 500ms (01F4 hex)
 000                           CONSTANT shift_delay_lsb, F4
 000                           ;
 000                           ;
 000                           ;
 000                           ;
 000                           ;Constant to define a software delay of 1us. This must be adjusted to reflect the
 000                           ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
 000                           ;calculation highly predictable. The '6' in the following equation even allows for
 000                           ;'CALL delay_1us' instruction in the initiating code.
 000                           ;
 000                           ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 000                           ;
 000                           ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
 000                           ;For clock rates below 10MHz the value of 1 must be used and the operation will
 000                           ;become lower than intended.
 000                           ;
 000                           CONSTANT delay_1us_constant, 0B
 000                           ;
 000                           ;
 000                           ;
 000                           ;ASCII table
 000                           ;
 000                           CONSTANT character_a, 61
 000                           CONSTANT character_b, 62
 000                           CONSTANT character_c, 63
 000                           CONSTANT character_d, 64
 000                           CONSTANT character_e, 65
 000                           CONSTANT character_f, 66
 000                           CONSTANT character_g, 67
 000                           CONSTANT character_h, 68
 000                           CONSTANT character_i, 69
 000                           CONSTANT character_j, 6A
 000                           CONSTANT character_k, 6B
 000                           CONSTANT character_l, 6C
 000                           CONSTANT character_m, 6D
 000                           CONSTANT character_n, 6E
 000                           CONSTANT character_o, 6F
 000                           CONSTANT character_p, 70
 000                           CONSTANT character_q, 71
 000                           CONSTANT character_r, 72
 000                           CONSTANT character_s, 73
 000                           CONSTANT character_t, 74
 000                           CONSTANT character_u, 75
 000                           CONSTANT character_v, 76
 000                           CONSTANT character_w, 77
 000                           CONSTANT character_x, 78
 000                           CONSTANT character_y, 79
 000                           CONSTANT character_z, 7A
 000                           CONSTANT character_A, 41
 000                           CONSTANT character_B, 42
 000                           CONSTANT character_C, 43
 000                           CONSTANT character_D, 44
 000                           CONSTANT character_E, 45
 000                           CONSTANT character_F, 46
 000                           CONSTANT character_G, 47
 000                           CONSTANT character_H, 48
 000                           CONSTANT character_I, 49
 000                           CONSTANT character_J, 4A
 000                           CONSTANT character_K, 4B
 000                           CONSTANT character_L, 4C
 000                           CONSTANT character_M, 4D
 000                           CONSTANT character_N, 4E
 000                           CONSTANT character_O, 4F
 000                           CONSTANT character_P, 50
 000                           CONSTANT character_Q, 51
 000                           CONSTANT character_R, 52
 000                           CONSTANT character_S, 53
 000                           CONSTANT character_T, 54
 000                           CONSTANT character_U, 55
 000                           CONSTANT character_V, 56
 000                           CONSTANT character_W, 57
 000                           CONSTANT character_X, 58
 000                           CONSTANT character_Y, 59
 000                           CONSTANT character_Z, 5A
 000                           CONSTANT character_0, 30
 000                           CONSTANT character_1, 31
 000                           CONSTANT character_2, 32
 000                           CONSTANT character_3, 33
 000                           CONSTANT character_4, 34
 000                           CONSTANT character_5, 35
 000                           CONSTANT character_6, 36
 000                           CONSTANT character_7, 37
 000                           CONSTANT character_8, 38
 000                           CONSTANT character_9, 39
 000                           CONSTANT character_colon, 3A
 000                           CONSTANT character_stop, 2E
 000                           CONSTANT character_semi_colon, 3B
 000                           CONSTANT character_minus, 2D
 000                           CONSTANT character_divide, 2F       ;'/'
 000                           CONSTANT character_plus, 2B
 000                           CONSTANT character_comma, 2C
 000                           CONSTANT character_less_than, 3C
 000                           CONSTANT character_greater_than, 3E
 000                           CONSTANT character_equals, 3D
 000                           CONSTANT character_space, 20
 000                           CONSTANT character_CR, 0D           ;carriage return
 000                           CONSTANT character_question, 3F     ;'?'
 000                           CONSTANT character_dollar, 24
 000                           CONSTANT character_exclaim, 21      ;'!'
 000                           CONSTANT character_BS, 08           ;Back Space command character
 000                           ;
 000                           ;
 000                           ;
 000                           ;
 000                           ;
 000                           ;**************************************************************************************
 000                           ;Initialise the system
 000                           ;**************************************************************************************
 000                           ;
 000  300E2        cold_start: CALL LCD_reset[0E2]                 ;initialise LCD display
 001  3C001                    ENABLE INTERRUPT
 002                           ;
 002                           ;Write welcome message to LCD display
 002                           ;
 002  00510                    LOAD s5, 10                         ;Line 1 position 0
 003  300F8                    CALL LCD_cursor[0F8]
 004  3003A                    CALL disp_SPARTAN[03A]              ;Display 'SPARTAN-3E STARTER KIT'
 005  0052E                    LOAD s5, 2E                         ;Line 2 position 14
 006  300F8                    CALL LCD_cursor[0F8]
 007  3004F                    CALL disp_www[04F]                  ;Display 'www.xilinx.com/s3estarter'
 008                           ;
 008  00008                    LOAD s0, 08                         ;initialise walking '1' pattern
 009  2E002                    STORE s0, LED_pattern[02]
 00A                           ;
 00A  00DFF                    LOAD sD, FF                         ;initial mode is rotary control
 00B  2ED03                    STORE sD, mode[03]
 00C                           ;
 00C                           ;**************************************************************************************
 00C                           ;Main program
 00C                           ;**************************************************************************************
 00C                           ;
 00C                           ;The main program is responsible for continuously shifting the LCD display
 00C                           ;at 0.5 second intervals. It also polls the centre press button of the rotary
 00C                           ;encoder to determine which mode of LED control should be active.
 00C                           ;
 00C                           ;
 00C  00F01   LCD_shift_delay: LOAD sF, shift_delay_msb[01]        ; [sF,sE]=loop delay in ms
 00D  00EF4                    LOAD sE, shift_delay_lsb[F4]
 00E  04001    LCD_delay_loop: INPUT s0, rotary_port[01]           ;test for press of rotary
 00F  12002                    TEST s0, rotary_press[02]
 010  3541C                    JUMP NZ, mode_switch[01C]
 011  06D03                    FETCH sD, mode[03]                  ;perform control task required
 012  14D00                    COMPARE sD, 00
 013  31029                    CALL Z, normal_mode[029]
 014  14DFF                    COMPARE sD, FF
 015  3102C                    CALL Z, rotate_mode[02C]
 016  30090                    CALL delay_1ms[090]                 ;1ms delay
 017  1CE01                    SUB sE, 01                          ;decrement delay counter
 018  1EF00                    SUBCY sF, 00
 019  35C0E                    JUMP NC, LCD_delay_loop[00E]
 01A  30102                    CALL LCD_shift_left[102]            ;shift LCD display
 01B  3400C                    JUMP LCD_shift_delay[00C]
 01C                           ;
 01C  0EDFF       mode_switch: XOR sD, FF                          ;toggle mode
 01D  2ED03                    STORE sD, mode[03]
 01E  30090  wait_mode_switch: CALL delay_1ms[090]                 ;keep shifting LCD display while waiting
 01F  1CE01                    SUB sE, 01
 020  1EF00                    SUBCY sF, 00
 021  35C25                    JUMP NC, wait_no_shift[025]
 022  30102                    CALL LCD_shift_left[102]            ;shift LCD display
 023  00F01                    LOAD sF, shift_delay_msb[01]        ; [sF,sE]=loop delay in ms
 024  00EF4                    LOAD sE, shift_delay_lsb[F4]
 025  04001     wait_no_shift: INPUT s0, rotary_port[01]           ;wait for release of press button
 026  12002                    TEST s0, rotary_press[02]
 027  3541E                    JUMP NZ, wait_mode_switch[01E]
 028  3400E                    JUMP LCD_delay_loop[00E]
 029                           ;
 029                           ;This procedure will copy the condition of the slide switches and press
 029                           ;buttons to the LEDs.
 029                           ;
 029                           ;
 029  04000       normal_mode: INPUT s0, switch_port[00]           ;Read switches and buttons and directly drive LEDs
 02A  2C080                    OUTPUT s0, LED_port[80]
 02B  2A000                    RETURN
 02C                           ;
 02C                           ;
 02C                           ;
 02C                           ;This procedure will poll the status of the rotary encoder.
 02C                           ;If rotation occurs, then the LED pattern will adjust appropriately.
 02C                           ;
 02C  06A02       rotate_mode: FETCH sA, LED_pattern[02]           ;last known position
 02D  06000                    FETCH s0, rotary_status[00]         ;check status of rotation
 02E  12080                    TEST s0, 80                         ;test flag
 02F  35037                    JUMP Z, update_pattern[037]
 030  0A07F                    AND s0, 7F                          ;clear flag
 031  2E000                    STORE s0, rotary_status[00]
 032  12001                    TEST s0, rotary_left[01]            ;event occurred so update pattern
 033  35036                    JUMP Z, move_right[036]
 034  20A02                    RL sA
 035  34037                    JUMP update_pattern[037]
 036  20A0C        move_right: RR sA
 037  2EA02    update_pattern: STORE sA, LED_pattern[02]
 038  2CA80                    OUTPUT sA, LED_port[80]             ;drive LEDs with current pattern
 039  2A000                    RETURN
 03A                           ;
 03A                           ;
 03A                           ;
 03A                           ;
 03A                           ;**************************************************************************************
 03A                           ;LCD text messages
 03A                           ;**************************************************************************************
 03A                           ;
 03A                           ;
 03A                           ;Display 'SPARTAN-3E STARTER KIT' on LCD at current cursor position
 03A                           ;
 03A                           ;
 03A  00553      disp_SPARTAN: LOAD s5, character_S[53]
 03B  300B8                    CALL LCD_write_data[0B8]
 03C  0054D                    LOAD s5, character_M[4D]
 03D  300B8                    CALL LCD_write_data[0B8]
 03E  00541                    LOAD s5, character_A[41]
 03F  300B8                    CALL LCD_write_data[0B8]
 040  00552                    LOAD s5, character_R[52]
 041  300B8                    CALL LCD_write_data[0B8]
 042  00554                    LOAD s5, character_T[54]
 043  300B8                    CALL LCD_write_data[0B8]
 044  00542                    LOAD s5, character_B[42]
 045  300B8                    CALL LCD_write_data[0B8]
 046  0054F                    LOAD s5, character_O[4F]
 047  300B8                    CALL LCD_write_data[0B8]
 048  00541                    LOAD s5, character_A[41]
 049  300B8                    CALL LCD_write_data[0B8]
 04A  00552                    LOAD s5, character_R[52]
 04B  300B8                    CALL LCD_write_data[0B8]
 04C  00544                    LOAD s5, character_D[44]
 04D  300B8                    CALL LCD_write_data[0B8]
 04E  2A000                    RETURN
 04F                           ;
 04F                           ;
 04F                           ;Display 'www.xilinx.com/s3estarter' on LCD at current cursor position
 04F                           ;
 04F                           ;
 04F  00577          disp_www: LOAD s5, character_w[77]
 050  300B8                    CALL LCD_write_data[0B8]
 051  00577                    LOAD s5, character_w[77]
 052  300B8                    CALL LCD_write_data[0B8]
 053  00577                    LOAD s5, character_w[77]
 054  300B8                    CALL LCD_write_data[0B8]
 055  0052E                    LOAD s5, character_stop[2E]
 056  300B8                    CALL LCD_write_data[0B8]
 057  00561                    LOAD s5, character_a[61]
 058  300B8                    CALL LCD_write_data[0B8]
 059  00572                    LOAD s5, character_r[72]
 05A  300B8                    CALL LCD_write_data[0B8]
 05B  0056C                    LOAD s5, character_l[6C]
 05C  300B8                    CALL LCD_write_data[0B8]
 05D  00579                    LOAD s5, character_y[79]
 05E  300B8                    CALL LCD_write_data[0B8]
 05F  00573                    LOAD s5, character_s[73]
 060  300B8                    CALL LCD_write_data[0B8]
 061  00563                    LOAD s5, character_c[63]
 062  300B8                    CALL LCD_write_data[0B8]
 063  00561                    LOAD s5, character_a[61]
 064  300B8                    CALL LCD_write_data[0B8]
 065  0056C                    LOAD s5, character_l[6C]
 066  300B8                    CALL LCD_write_data[0B8]
 067  00565                    LOAD s5, character_e[65]
 068  300B8                    CALL LCD_write_data[0B8]
 069  00573                    LOAD s5, character_s[73]
 06A  300B8                    CALL LCD_write_data[0B8]
 06B  0052E                    LOAD s5, character_stop[2E]
 06C  300B8                    CALL LCD_write_data[0B8]
 06D  00563                    LOAD s5, character_c[63]
 06E  300B8                    CALL LCD_write_data[0B8]
 06F  0056F                    LOAD s5, character_o[6F]
 070  300B8                    CALL LCD_write_data[0B8]
 071  0056D                    LOAD s5, character_m[6D]
 072  300B8                    CALL LCD_write_data[0B8]
 073  0052F                    LOAD s5, character_divide[2F]
 074  300B8                    CALL LCD_write_data[0B8]
 075  00569                    LOAD s5, character_i[69]
 076  300B8                    CALL LCD_write_data[0B8]
 077  0056F                    LOAD s5, character_o[6F]
 078  300B8                    CALL LCD_write_data[0B8]
 079  00562                    LOAD s5, character_b[62]
 07A  300B8                    CALL LCD_write_data[0B8]
 07B  0056F                    LOAD s5, character_o[6F]
 07C  300B8                    CALL LCD_write_data[0B8]
 07D  00561                    LOAD s5, character_a[61]
 07E  300B8                    CALL LCD_write_data[0B8]
 07F  00572                    LOAD s5, character_r[72]
 080  300B8                    CALL LCD_write_data[0B8]
 081  00564                    LOAD s5, character_d[64]
 082  300B8                    CALL LCD_write_data[0B8]
 083  2A000                    RETURN
 084                           ;
 084                           ;Display a space on LCD at current cursor position
 084                           ;
 084                           ;
 084  00520        disp_space: LOAD s5, character_space[20]
 085  300B8                    CALL LCD_write_data[0B8]
 086  2A000                    RETURN
 087                           ;
 087                           ;
 087                           ;
 087                           ;
 087                           ;**************************************************************************************
 087                           ;Software delay routines
 087                           ;**************************************************************************************
 087                           ;
 087                           ;
 087                           ;
 087                           ;Delay of 1us.
 087                           ;
 087                           ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
 087                           ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
 087                           ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
 087                           ;
 087                           ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 087                           ;
 087                           ;Registers used s0
 087                           ;
 087  0000B         delay_1us: LOAD s0, delay_1us_constant[0B]
 088  1C001          wait_1us: SUB s0, 01
 089  35488                    JUMP NZ, wait_1us[088]
 08A  2A000                    RETURN
 08B                           ;
 08B                           ;Delay of 40us.
 08B                           ;
 08B                           ;Registers used s0, s1
 08B                           ;
 08B  00128        delay_40us: LOAD s1, 28                         ;40 x 1us = 40us
 08C  30087         wait_40us: CALL delay_1us[087]
 08D  1C101                    SUB s1, 01
 08E  3548C                    JUMP NZ, wait_40us[08C]
 08F  2A000                    RETURN
 090                           ;
 090                           ;
 090                           ;Delay of 1ms.
 090                           ;
 090                           ;Registers used s0, s1, s2
 090                           ;
 090  00219         delay_1ms: LOAD s2, 19                         ;25 x 40us = 1ms
 091  3008B          wait_1ms: CALL delay_40us[08B]
 092  1C201                    SUB s2, 01
 093  35491                    JUMP NZ, wait_1ms[091]
 094  2A000                    RETURN
 095                           ;
 095                           ;Delay of 20ms.
 095                           ;
 095                           ;Delay of 20ms used during initialisation.
 095                           ;
 095                           ;Registers used s0, s1, s2, s3
 095                           ;
 095  00314        delay_20ms: LOAD s3, 14                         ;20 x 1ms = 20ms
 096  30090         wait_20ms: CALL delay_1ms[090]
 097  1C301                    SUB s3, 01
 098  35496                    JUMP NZ, wait_20ms[096]
 099  2A000                    RETURN
 09A                           ;
 09A                           ;Delay of approximately 1 second.
 09A                           ;
 09A                           ;Registers used s0, s1, s2, s3, s4
 09A                           ;
 09A  00432          delay_1s: LOAD s4, 32                         ;50 x 20ms = 1000ms
 09B  30095           wait_1s: CALL delay_20ms[095]
 09C  1C401                    SUB s4, 01
 09D  3549B                    JUMP NZ, wait_1s[09B]
 09E  2A000                    RETURN
 09F                           ;
 09F                           ;
 09F                           ;
 09F                           ;**************************************************************************************
 09F                           ;LCD Character Module Routines
 09F                           ;**************************************************************************************
 09F                           ;
 09F                           ;LCD module is a 16 character by 2 line display but all displays are very similar
 09F                           ;The 4-wire data interface will be used (DB4 to DB7).
 09F                           ;
 09F                           ;The LCD modules are relatively slow and software delay loops are used to slow down
 09F                           ;KCPSM3 adequately for the LCD to communicate. The delay routines are provided in
 09F                           ;a different section (see above in this case).
 09F                           ;
 09F                           ;
 09F                           ;Pulse LCD enable signal 'E' high for greater than 230ns (1us is used).
 09F                           ;
 09F                           ;Register s4 should define the current state of the LCD output port.
 09F                           ;
 09F                           ;Registers used s0, s4
 09F                           ;
 09F  0E401       LCD_pulse_E: XOR s4, LCD_E[01]                   ;E=1
 0A0  2C440                    OUTPUT s4, LCD_output_port[40]
 0A1  30087                    CALL delay_1us[087]
 0A2  0E401                    XOR s4, LCD_E[01]                   ;E=0
 0A3  2C440                    OUTPUT s4, LCD_output_port[40]
 0A4  2A000                    RETURN
 0A5                           ;
 0A5                           ;Write 4-bit instruction to LCD display.
 0A5                           ;
 0A5                           ;The 4-bit instruction should be provided in the upper 4-bits of register s4.
 0A5                           ;Note that this routine does not release the master enable but as it is only
 0A5                           ;used during initialisation and as part of the 8-bit instruction write it
 0A5                           ;should be acceptable.
 0A5                           ;
 0A5                           ;Registers used s4
 0A5                           ;
 0A5  0A4F8   LCD_write_inst4: AND s4, F8                          ;Enable=1 RS=0 Instruction, RW=0 Write, E=0
 0A6  2C440                    OUTPUT s4, LCD_output_port[40]      ;set up RS and RW >40ns before enable pulse
 0A7  3009F                    CALL LCD_pulse_E[09F]
 0A8  2A000                    RETURN
 0A9                           ;
 0A9                           ;
 0A9                           ;Write 8-bit instruction to LCD display.
 0A9                           ;
 0A9                           ;The 8-bit instruction should be provided in register s5.
 0A9                           ;Instructions are written using the following sequence
 0A9                           ; Upper nibble
 0A9                           ; wait >1us
 0A9                           ; Lower nibble
 0A9                           ; wait >40us
 0A9                           ;
 0A9                           ;Registers used s0, s1, s4, s5
 0A9                           ;
 0A9  01450   LCD_write_inst8: LOAD s4, s5
 0AA  0A4F0                    AND s4, F0                          ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 0AB  0C408                    OR s4, LCD_drive[08]                ;Enable=1
 0AC  300A5                    CALL LCD_write_inst4[0A5]           ;write upper nibble
 0AD  30087                    CALL delay_1us[087]                 ;wait >1us
 0AE  01450                    LOAD s4, s5                         ;select lower nibble with
 0AF  20407                    SL1 s4                              ;Enable=1
 0B0  20406                    SL0 s4                              ;RS=0 Instruction
 0B1  20406                    SL0 s4                              ;RW=0 Write
 0B2  20406                    SL0 s4                              ;E=0
 0B3  300A5                    CALL LCD_write_inst4[0A5]           ;write lower nibble
 0B4  3008B                    CALL delay_40us[08B]                ;wait >40us
 0B5  004F0                    LOAD s4, F0                         ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 0B6  2C440                    OUTPUT s4, LCD_output_port[40]      ;Release master enable
 0B7  2A000                    RETURN
 0B8                           ;
 0B8                           ;
 0B8                           ;
 0B8                           ;Write 8-bit data to LCD display.
 0B8                           ;
 0B8                           ;The 8-bit data should be provided in register s5.
 0B8                           ;Data bytes are written using the following sequence
 0B8                           ; Upper nibble
 0B8                           ; wait >1us
 0B8                           ; Lower nibble
 0B8                           ; wait >40us
 0B8                           ;
 0B8                           ;Registers used s0, s1, s4, s5
 0B8                           ;
 0B8  01450    LCD_write_data: LOAD s4, s5
 0B9  0A4F0                    AND s4, F0                          ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 0BA  0C40C                    OR s4, 0C                           ;Enable=1 RS=1 Data, RW=0 Write, E=0
 0BB  2C440                    OUTPUT s4, LCD_output_port[40]      ;set up RS and RW >40ns before enable pulse
 0BC  3009F                    CALL LCD_pulse_E[09F]               ;write upper nibble
 0BD  30087                    CALL delay_1us[087]                 ;wait >1us
 0BE  01450                    LOAD s4, s5                         ;select lower nibble with
 0BF  20407                    SL1 s4                              ;Enable=1
 0C0  20407                    SL1 s4                              ;RS=1 Data
 0C1  20406                    SL0 s4                              ;RW=0 Write
 0C2  20406                    SL0 s4                              ;E=0
 0C3  2C440                    OUTPUT s4, LCD_output_port[40]      ;set up RS and RW >40ns before enable pulse
 0C4  3009F                    CALL LCD_pulse_E[09F]               ;write lower nibble
 0C5  3008B                    CALL delay_40us[08B]                ;wait >40us
 0C6  004F0                    LOAD s4, F0                         ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 0C7  2C440                    OUTPUT s4, LCD_output_port[40]      ;Release master enable
 0C8  2A000                    RETURN
 0C9                           ;
 0C9                           ;
 0C9                           ;
 0C9                           ;
 0C9                           ;Read 8-bit data from LCD display.
 0C9                           ;
 0C9                           ;The 8-bit data will be read from the current LCD memory address
 0C9                           ;and will be returned in register s5.
 0C9                           ;It is advisable to set the LCD address (cursor position) before
 0C9                           ;using the data read for the first time otherwise the display may
 0C9                           ;generate invalid data on the first read.
 0C9                           ;
 0C9                           ;Data bytes are read using the following sequence
 0C9                           ; Upper nibble
 0C9                           ; wait >1us
 0C9                           ; Lower nibble
 0C9                           ; wait >40us
 0C9                           ;
 0C9                           ;Registers used s0, s1, s4, s5
 0C9                           ;
 0C9  0040E    LCD_read_data8: LOAD s4, 0E                         ;Enable=1 RS=1 Data, RW=1 Read, E=0
 0CA  2C440                    OUTPUT s4, LCD_output_port[40]      ;set up RS and RW >40ns before enable pulse
 0CB  0E401                    XOR s4, LCD_E[01]                   ;E=1
 0CC  2C440                    OUTPUT s4, LCD_output_port[40]
 0CD  30087                    CALL delay_1us[087]                 ;wait >260ns to access data
 0CE  04502                    INPUT s5, LCD_input_port[02]        ;read upper nibble
 0CF  0E401                    XOR s4, LCD_E[01]                   ;E=0
 0D0  2C440                    OUTPUT s4, LCD_output_port[40]
 0D1  30087                    CALL delay_1us[087]                 ;wait >1us
 0D2  0E401                    XOR s4, LCD_E[01]                   ;E=1
 0D3  2C440                    OUTPUT s4, LCD_output_port[40]
 0D4  30087                    CALL delay_1us[087]                 ;wait >260ns to access data
 0D5  04002                    INPUT s0, LCD_input_port[02]        ;read lower nibble
 0D6  0E401                    XOR s4, LCD_E[01]                   ;E=0
 0D7  2C440                    OUTPUT s4, LCD_output_port[40]
 0D8  0A5F0                    AND s5, F0                          ;merge upper and lower nibbles
 0D9  2000E                    SR0 s0
 0DA  2000E                    SR0 s0
 0DB  2000E                    SR0 s0
 0DC  2000E                    SR0 s0
 0DD  0D500                    OR s5, s0
 0DE  00404                    LOAD s4, 04                         ;Enable=0 RS=1 Data, RW=0 Write, E=0
 0DF  2C440                    OUTPUT s4, LCD_output_port[40]      ;Stop reading 5V device and release master enable
 0E0  3008B                    CALL delay_40us[08B]                ;wait >40us
 0E1  2A000                    RETURN
 0E2                           ;
 0E2                           ;
 0E2                           ;Reset and initialise display to communicate using 4-bit data mode
 0E2                           ;Includes routine to clear the display.
 0E2                           ;
 0E2                           ;Requires the 4-bit instructions 3,3,3,2 to be sent with suitable delays
 0E2                           ;following by the 8-bit instructions to set up the display.
 0E2                           ;
 0E2                           ;  28 = '001' Function set, '0' 4-bit mode, '1' 2-line, '0' 5x7 dot matrix, 'xx'
 0E2                           ;  06 = '000001' Entry mode, '1' increment, '0' no display shift
 0E2                           ;  0C = '00001' Display control, '1' display on, '0' cursor off, '0' cursor blink off
 0E2                           ;  01 = '00000001' Display clear
 0E2                           ;
 0E2                           ;Registers used s0, s1, s2, s3, s4
 0E2                           ;
 0E2  30095         LCD_reset: CALL delay_20ms[095]                ;wait more that 15ms for display to be ready
 0E3  00430                    LOAD s4, 30
 0E4  300A5                    CALL LCD_write_inst4[0A5]           ;send '3'
 0E5  30095                    CALL delay_20ms[095]                ;wait >4.1ms
 0E6  300A5                    CALL LCD_write_inst4[0A5]           ;send '3'
 0E7  30090                    CALL delay_1ms[090]                 ;wait >100us
 0E8  300A5                    CALL LCD_write_inst4[0A5]           ;send '3'
 0E9  3008B                    CALL delay_40us[08B]                ;wait >40us
 0EA  00420                    LOAD s4, 20
 0EB  300A5                    CALL LCD_write_inst4[0A5]           ;send '2'
 0EC  3008B                    CALL delay_40us[08B]                ;wait >40us
 0ED  00528                    LOAD s5, 28                         ;Function set
 0EE  300A9                    CALL LCD_write_inst8[0A9]
 0EF  00506                    LOAD s5, 06                         ;Entry mode
 0F0  300A9                    CALL LCD_write_inst8[0A9]
 0F1  0050C                    LOAD s5, 0C                         ;Display control
 0F2  300A9                    CALL LCD_write_inst8[0A9]
 0F3  00501         LCD_clear: LOAD s5, 01                         ;Display clear
 0F4  300A9                    CALL LCD_write_inst8[0A9]
 0F5  30090                    CALL delay_1ms[090]                 ;wait >1.64ms for display to clear
 0F6  30090                    CALL delay_1ms[090]
 0F7  2A000                    RETURN
 0F8                           ;
 0F8                           ;Position the cursor ready for characters to be written.
 0F8                           ;The display is formed of 2 lines of 16 characters and each
 0F8                           ;position has a corresponding address as indicated below.
 0F8                           ;
 0F8                           ;                   Character position
 0F8                           ;           0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
 0F8                           ;
 0F8                           ; Line 1 - 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F
 0F8                           ; Line 2 - C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF
 0F8                           ;
 0F8                           ;This routine will set the cursor position using the value provided
 0F8                           ;in register s5. The upper nibble will define the line and the lower
 0F8                           ;nibble the character position on the line.
 0F8                           ; Example s5 = 2B will position the cursor on line 2 position 11
 0F8                           ;
 0F8                           ;Registers used s0, s1, s2, s3, s4
 0F8                           ;
 0F8  12510        LCD_cursor: TEST s5, 10                         ;test for line 1
 0F9  350FE                    JUMP Z, set_line2[0FE]
 0FA  0A50F                    AND s5, 0F                          ;make address in range 80 to 8F for line 1
 0FB  0C580                    OR s5, 80
 0FC  300A9                    CALL LCD_write_inst8[0A9]           ;instruction write to set cursor
 0FD  2A000                    RETURN
 0FE  0A50F         set_line2: AND s5, 0F                          ;make address in range C0 to CF for line 2
 0FF  0C5C0                    OR s5, C0
 100  300A9                    CALL LCD_write_inst8[0A9]           ;instruction write to set cursor
 101  2A000                    RETURN
 102                           ;
 102                           ;This routine will shift the complete display one position to the left.
 102                           ;The cursor position and LCD memory contents will not change.
 102                           ;
 102                           ;
 102                           ;Registers used s0, s1, s2, s3, s4, s5
 102                           ;
 102  00518    LCD_shift_left: LOAD s5, 18                         ;shift display left
 103  300A9                    CALL LCD_write_inst8[0A9]
 104  2A000                    RETURN
 105                           ;
 105                           ;**************************************************************************************
 105                           ;Interrupt Service Routine (ISR)
 105                           ;**************************************************************************************
 105                           ;
 105                           ;Interrupts occur when the rotary control has been moved.
 105                           ;
 105                           ;The ISR captures the state of the direction which it writes to scratch pad memory (SPM).
 105                           ;The most significant bit is also set at this location to provide a 'flag' to the
 105                           ;main body of the program.
 105                           ;
 105                           ;If the main program is not in rotation mode then the ISR effectively ignores the
 105                           ;event although the hardware interface will be cleared by the interrupt_ack signal.
 105                           ;This prevents a rotation event which has been made during normal switch and button
 105                           ;mode from having any effect.
 105                           ;
 105  2E001               ISR: STORE s0, ISR_preserve_s0[01]       ;preserve s0
 106  06003                    FETCH s0, mode[03]                  ;test operation mode
 107  14000                    COMPARE s0, 00                      ;ignore events under normal mode
 108  3510C                    JUMP Z, end_ISR[10C]
 109  04001                    INPUT s0, rotary_port[01]           ;read rotary encoder
 10A  0C080                    OR s0, 80                           ;set flag
 10B  2E000                    STORE s0, rotary_status[00]         ;put result in SCM
 10C  06001           end_ISR: FETCH s0, ISR_preserve_s0[01]       ;restore s0
 10D  38001                    RETURNI ENABLE
 10E                           ;
 10E                           ;
 10E                           ;**************************************************************************************
 10E                           ;Interrupt Vector
 10E                           ;**************************************************************************************
 10E                           ;
 3FF                           ADDRESS 3FF
 3FF  34105                    JUMP ISR[105]
 3FF                           ;
 3FF                           ;
