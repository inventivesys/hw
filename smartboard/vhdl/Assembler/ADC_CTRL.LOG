KCPSM3 Assembler log file for program 'adc_ctrl.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
05Feb2007-10:27:29

 Addr Code

 000                             ;KCPSM3 Program - SPI Control of Amplifier and A/D converter on Spartan-3E Starter Kit.
 000                             ;
 000                             ;
 000                             ;Ken Chapman - Xilinx Ltd
 000                             ;
 000                             ;Version v1.00 - 21th December 2005
 000                             ;
 000                             ;This program uses an 8KHz interrupt to generate test waveforms on the
 000                             ;4 analogue outputs provided by the Linear Technology LTC2624 device.
 000                             ;
 000                             ;As well as the port connections vital to communication with the UART and the SPI
 000                             ;FLASH memory, there are additional port connections used to disable the other
 000                             ;devices sharing the SPI bus on the Starter Kit board. Although these could have been
 000                             ;controlled at the hardware level, they are included in this code to aid
 000                             ;future investigations of communication with the other SPI devices using PicoBlaze.
 000                             ;
 000                             ;Connections to the LEDs, switches and press buttons are provided to aid
 000                             ;development and enable further experiments. Otherwise know as having fun!
 000                             ;
 000                             ;Port definitions
 000                             ;
 000                             ;
 000                             CONSTANT SPI_control_port, 08           ;SPI clock and chip selects
 000                             CONSTANT SPI_sck, 01                    ;                  SCK - bit0
 000                             CONSTANT SPI_rom_cs, 02                 ;    serial rom select - bit1
 000                             CONSTANT SPI_spare_control, 04          ;                spare - bit2
 000                             CONSTANT SPI_amp_cs, 08                 ;     amplifier select - bit3
 000                             CONSTANT SPI_adc_conv, 10               ;          A/D convert - bit4
 000                             CONSTANT SPI_dac_cs, 20                 ;           D/A select - bit5
 000                             CONSTANT SPI_amp_shdn, 40               ;       amplifier SHDN - bit6
 000                             CONSTANT SPI_dac_clr, 80                ;            D/A clear - bit7
 000                             ;
 000                             CONSTANT SPI_output_port, 04            ;SPI data output
 000                             CONSTANT SPI_sdo, 80                    ;   SDO - bit7
 000                             ;
 000                             CONSTANT SPI_input_port, 01             ;SPI data input
 000                             CONSTANT SPI_sdi, 80                    ;             SDI - bit7
 000                             CONSTANT SPI_amp_sdi, 40                ;   amplifier SDI - bit6
 000                             ;
 000                             ;
 000                             CONSTANT LED_port, 80                   ;8 simple LEDs
 000                             CONSTANT LED0, 01                       ;     LED 0 - bit0
 000                             CONSTANT LED1, 02                       ;         1 - bit1
 000                             CONSTANT LED2, 04                       ;         2 - bit2
 000                             CONSTANT LED3, 08                       ;         3 - bit3
 000                             CONSTANT LED4, 10                       ;         4 - bit4
 000                             CONSTANT LED5, 20                       ;         5 - bit5
 000                             CONSTANT LED6, 40                       ;         6 - bit6
 000                             CONSTANT LED7, 80                       ;         7 - bit7
 000                             ;
 000                             ;
 000                             CONSTANT switch_port, 00                ;Read switches and press buttons
 000                             CONSTANT BTN_north, 01                  ;  Buttons     North - bit0
 000                             CONSTANT BTN_east, 02                   ;               East - bit1
 000                             CONSTANT BTN_south, 04                  ;              South - bit2
 000                             CONSTANT BTN_west, 08                   ;               West - bit3
 000                             CONSTANT switch0, 10                    ;  Switches        0 - bit4
 000                             CONSTANT switch1, 20                    ;                  1 - bit5
 000                             CONSTANT switch2, 40                    ;                  2 - bit6
 000                             CONSTANT switch3, 80                    ;                  3 - bit7
 000                             ;
 000                             ;LCD interface ports
 000                             ;
 000                             ;The master enable signal is not used by the LCD display itself
 000                             ;but may be required to confirm that LCD communication is active.
 000                             ;This is required on the Spartan-3E Starter Kit if the StrataFLASH
 000                             ;is used because it shares the same data pins and conflicts must be avoided.
 000                             ;
 000                             CONSTANT LCD_output_port, 40            ;LCD character module output data and control
 000                             CONSTANT LCD_E, 01                      ;   active High Enable        E - bit0
 000                             CONSTANT LCD_RW, 02                     ;   Read=1 Write=0           RW - bit1
 000                             CONSTANT LCD_RS, 04                     ;   Instruction=0 Data=1     RS - bit2
 000                             CONSTANT LCD_drive, 08                  ;   Master enable (active High) - bit3
 000                             CONSTANT LCD_DB4, 10                    ;   4-bit              Data DB4 - bit4
 000                             CONSTANT LCD_DB5, 20                    ;   interface          Data DB5 - bit5
 000                             CONSTANT LCD_DB6, 40                    ;                      Data DB6 - bit6
 000                             CONSTANT LCD_DB7, 80                    ;                      Data DB7 - bit7
 000                             ;
 000                             ;
 000                             CONSTANT LCD_input_port, 02             ;LCD character module input data
 000                             CONSTANT LCD_read_spare0, 01            ;    Spare bits               - bit0
 000                             CONSTANT LCD_read_spare1, 02            ;    are zero                 - bit1
 000                             CONSTANT LCD_read_spare2, 04            ;                             - bit2
 000                             CONSTANT LCD_read_spare3, 08            ;                             - bit3
 000                             CONSTANT LCD_read_DB4, 10               ;    4-bit           Data DB4 - bit4
 000                             CONSTANT LCD_read_DB5, 20               ;    interface       Data DB5 - bit5
 000                             CONSTANT LCD_read_DB6, 40               ;                    Data DB6 - bit6
 000                             CONSTANT LCD_read_DB7, 80               ;                    Data DB7 - bit7
 000                             ;
 000                             ;
 000                             CONSTANT UART_status_port, 04           ; UART status IN
 000                             CONSTANT UART_read_port, 06             ; UART Rx data IN
 000                             CONSTANT UART_write_port, 01            ; UART Tx data OUT
 000                             CONSTANT tx_half_full, 01               ; Transmitter     half full - bit0
 000                             CONSTANT tx_full, 02                    ; FIFO               full - bit1
 000                             CONSTANT rx_half_full, 08               ; Receiver        half full - bit3
 000                             CONSTANT rx_full, 10                    ; FIFO               full - bit4
 000                             CONSTANT rx_data_present, 04            ; data present - bit2
 000                             ;
 000                             ;
 000                             ;Special Register usage
 000                             ;
 000                             ;
 000                             ;
 000                             ;Scratch Pad Memory Locations
 000                             ;
 000                             ;Values read from the A/D converter
 000                             ;
 000                             CONSTANT ADC0_lsb, 00                   ;ADC Channel 0 value LS-Byte
 000                             CONSTANT ADC0_msb, 01                   ;                    MS-Byte
 000                             ;
 000                             CONSTANT ADC1_lsb, 02                   ;ADC Channel 1 value LS-Byte
 000                             CONSTANT ADC1_msb, 03                   ;                    MS-Byte
 000                             ;
 000                             ;Amplifier gain settings.
 000                             ;
 000                             ;Stored value is the 4-bit code for gain setting
 000                             ;  Code  1   2   3    4     5    6     7
 000                             ;  Gain -1  -2  -5  -10   -20  -50  -100
 000                             CONSTANT amp_A_gain, 04                 ;Amplifier A gain value
 000                             CONSTANT amp_B_gain, 05                 ;Amplifier B gain value
 000                             ;
 000                             ;Sample counter used to give activity indication on LEDs
 000                             ;
 000                             CONSTANT sample_count, 06               ;8-bit counter LS-Byte
 000                             ;
 000                             CONSTANT decimal0, 07                   ;5 digit decimal value
 000                             CONSTANT decimal1, 08
 000                             CONSTANT decimal2, 09
 000                             CONSTANT decimal3, 0A
 000                             CONSTANT decimal4, 0B
 000                             ;
 000                             ;
 000                             ;
 000                             ;
 000                             ;Useful data constants
 000                             ;
 000                             CONSTANT VREF_lsb, 72                   ;Reference voltage in milli-volts
 000                             CONSTANT VREF_msb, 06                   ;Nominal value 1.65v so value is 1650 (0672 hex)
 000                             ;
 000                             ;Constant to define a software delay of 1us. This must be adjusted to reflect the
 000                             ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
 000                             ;calculation highly predictable. The '6' in the following equation even allows for
 000                             ;'CALL delay_1us' instruction in the initiating code.
 000                             ;
 000                             ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 000                             ;
 000                             ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
 000                             ;For clock rates below 10MHz the value of 1 must be used and the operation will
 000                             ;become lower than intended.
 000                             ;
 000                             CONSTANT delay_1us_constant, 0B
 000                             ;
 000                             ;
 000                             CONSTANT string_start, 10
 000                             NAMEREG sB, uart_data                   ; used to pass data to and from UART
 000                             ;
 000                             ;ASCII table
 000                             ;
 000                             CONSTANT character_a, 61
 000                             CONSTANT character_b, 62
 000                             CONSTANT character_c, 63
 000                             CONSTANT character_d, 64
 000                             CONSTANT character_e, 65
 000                             CONSTANT character_f, 66
 000                             CONSTANT character_g, 67
 000                             CONSTANT character_h, 68
 000                             CONSTANT character_i, 69
 000                             CONSTANT character_j, 6A
 000                             CONSTANT character_k, 6B
 000                             CONSTANT character_l, 6C
 000                             CONSTANT character_m, 6D
 000                             CONSTANT character_n, 6E
 000                             CONSTANT character_o, 6F
 000                             CONSTANT character_p, 70
 000                             CONSTANT character_q, 71
 000                             CONSTANT character_r, 72
 000                             CONSTANT character_s, 73
 000                             CONSTANT character_t, 74
 000                             CONSTANT character_u, 75
 000                             CONSTANT character_v, 76
 000                             CONSTANT character_w, 77
 000                             CONSTANT character_x, 78
 000                             CONSTANT character_y, 79
 000                             CONSTANT character_z, 7A
 000                             CONSTANT character_A, 41
 000                             CONSTANT character_B, 42
 000                             CONSTANT character_C, 43
 000                             CONSTANT character_D, 44
 000                             CONSTANT character_E, 45
 000                             CONSTANT character_F, 46
 000                             CONSTANT character_G, 47
 000                             CONSTANT character_H, 48
 000                             CONSTANT character_I, 49
 000                             CONSTANT character_J, 4A
 000                             CONSTANT character_K, 4B
 000                             CONSTANT character_L, 4C
 000                             CONSTANT character_M, 4D
 000                             CONSTANT character_N, 4E
 000                             CONSTANT character_O, 4F
 000                             CONSTANT character_P, 50
 000                             CONSTANT character_Q, 51
 000                             CONSTANT character_R, 52
 000                             CONSTANT character_S, 53
 000                             CONSTANT character_T, 54
 000                             CONSTANT character_U, 55
 000                             CONSTANT character_V, 56
 000                             CONSTANT character_W, 57
 000                             CONSTANT character_X, 58
 000                             CONSTANT character_Y, 59
 000                             CONSTANT character_Z, 5A
 000                             CONSTANT character_0, 30
 000                             CONSTANT character_1, 31
 000                             CONSTANT character_2, 32
 000                             CONSTANT character_3, 33
 000                             CONSTANT character_4, 34
 000                             CONSTANT character_5, 35
 000                             CONSTANT character_6, 36
 000                             CONSTANT character_7, 37
 000                             CONSTANT character_8, 38
 000                             CONSTANT character_9, 39
 000                             CONSTANT character_colon, 3A
 000                             CONSTANT character_stop, 2E
 000                             CONSTANT character_semi_colon, 3B
 000                             CONSTANT character_minus, 2D
 000                             CONSTANT character_divide, 2F           ;'/'
 000                             CONSTANT character_plus, 2B
 000                             CONSTANT character_comma, 2C
 000                             CONSTANT character_less_than, 3C
 000                             CONSTANT character_greater_than, 3E
 000                             CONSTANT character_equals, 3D
 000                             CONSTANT character_space, 20
 000                             CONSTANT character_CR, 0D               ;carriage return
 000                             CONSTANT character_question, 3F         ;'?'
 000                             CONSTANT character_dollar, 24
 000                             CONSTANT character_exclaim, 21          ;'!'
 000                             CONSTANT character_BS, 08               ;Back Space command character
 000                             CONSTANT character_LF, 0A               ; line feed
 000                             ;
 000                             ;
 000                             ;
 000                             ;
 000                             ;
 000                             ;
 000                             ;Initialise the system
 000                             ;
 000                             ;
 000  30131          cold_start: CALL SPI_init[131]                      ;initialise SPI bus ports
 001  3022D                      CALL LCD_reset[22D]                     ;initialise LCD display
 002                             ;
 002                             ;Write welcome message to LCD display
 002                             ;
 002  00510                      LOAD s5, 10                             ;Line 1 position 0
 003  30243                      CALL LCD_cursor[243]
 004  30160                      CALL disp_PicoBlaze[160]                ;Display 'PicoBlaze Inside'
 005  00523                      LOAD s5, 23                             ;Line 2 position 3
 006  30243                      CALL LCD_cursor[243]
 007  30175                      CALL disp_ADC_Control[175]
 008  301E5                      CALL delay_1s[1E5]                      ;wait 5 seconds
 009  301E5                      CALL delay_1s[1E5]
 00A  301E5                      CALL delay_1s[1E5]
 00B  301E5                      CALL delay_1s[1E5]
 00C  301E5                      CALL delay_1s[1E5]
 00D  3023E                      CALL LCD_clear[23E]                     ;Clear display
 00E                             ;
 00E  00000                      LOAD s0, 00                             ;clear event counter
 00F  2E006                      STORE s0, sample_count[06]
 010                             ;
 010                             ;
 010                             ;
 010                             ;
 010  00001                      LOAD s0, 01                             ;set initial amplifier gain to 1 on both channels
 011  2E004                      STORE s0, amp_A_gain[04]
 012  2E005                      STORE s0, amp_B_gain[05]
 013  340A4                      JUMP new_gain_set[0A4]                  ;set, display the initial gain and enable interrupts
 014                             ;
 014                             ;
 014                             ;The program is interrupt driven to maintain an 8KHz sample rate. The main body
 014                             ;of the program waits for an interrupt to occur. The interrupt updates all four
 014                             ;analogue outputs with values stored in scratch pad memory. This takes approximately
 014                             ;58us of the 125us available between interrupts. The main program then prepares
 014                             ;new values for the analogue outputs (in less than 67us) before waiting for the
 014                             ;next interrupt.
 014                             ;
 014                             ;
 014  00FFF          warm_start: LOAD sF, FF                             ;flag set and wait for interrupt to be serviced
 015  3C001                      ENABLE INTERRUPT                        ;normal operation
 016  04E00            wait_int: INPUT sE, switch_port[00]               ;test for button press changes to amplifier gain
 017  12E01                      TEST sE, BTN_north[01]                  ;sE used as this in not effected by ISR
 018  35498                      JUMP NZ, gain_increase[098]
 019  12E04                      TEST sE, BTN_south[04]
 01A  3549F                      JUMP NZ, gain_decrease[09F]
 01B  14FFF                      COMPARE sF, FF                          ;wait for interrupt
 01C  35016                      JUMP Z, wait_int[016]                   ;interrupt clears the flag
 01D                             ;
 01D                             ;
 01D                             ;
 01D                             ;Drive LEDs with simple binary count of the samples to indicate
 01D                             ;that the design is active.
 01D                             ;
 01D  06006                      FETCH s0, sample_count[06]              ;increment counter
 01E  18001                      ADD s0, 01
 01F  2E006                      STORE s0, sample_count[06]
 020  2C080                      OUTPUT s0, LED_port[80]                 ;count increments at 1Hz
 021                             ;
 021                             ;
 021                             ;Display the A/D Channel 0 value as hex on LCD
 021                             ;
 021  00520                      LOAD s5, character_space[20]            ;ensure next position is cleared
 022  01B50                      LOAD uart_data[sB], s5
 023  301AB                      CALL send_to_UART[1AB]
 024  0052C                      LOAD s5, 2C                             ;Line 2 position 12
 025  30243                      CALL LCD_cursor[243]
 026  06001                      FETCH s0, ADC0_msb[01]
 027  301C9                      CALL disp_hex_byte[1C9]
 028  06000                      FETCH s0, ADC0_lsb[00]
 029  301C9                      CALL disp_hex_byte[1C9]
 02A  00520                      LOAD s5, character_space[20]            ;ensure next position is cleared
 02B  01B50                      LOAD uart_data[sB], s5
 02C  301AB                      CALL send_to_UART[1AB]
 02D                             ;
 02D                             ;
 02D                             ;
 02D                             ;Convert A/D channel 0 value to decimal voltage
 02D                             ;
 02D                             ;The 14-bit signed value from the A/D (sign extended to 16-bits)
 02D                             ;relates to a voltage in the range -1.25v to +1.25v at the input
 02D                             ;to the A/D converter relative to the 1.65v mid-rail reference point.
 02D                             ;
 02D                             ;The 14-bit value can be translated into the -1.25v to +1.25v using the
 02D                             ;simple equation...
 02D                             ;
 02D                             ;   ADin = AD_value x 1.25/8192
 02D                             ;
 02D                             ;It is possible to scale the AD_value by 1.25/8192 using a fixed point
 02D                             ;representation.
 02D                             ;
 02D                             ;However, it is also possible to scale it by another factor at the
 02D                             ;same time which nicely converts to a binary value which is readily
 02D                             ;converted to decimal. This can be achieved by example...
 02D                             ;
 02D                             ;For an input to the A/D converter of +1.25v relative to the reference,
 02D                             ;the A/D will output the maximum conversion of 1FFF (+8191).
 02D                             ;
 02D                             ;In this case we would like to have the result value +1.250v which can be represented
 02D                             ;by the integer value +1250 with appropiate positioning of the decimal point.
 02D                             ;The constant to achieve this conversion is +1250/8191=+0.152606...
 02D                             ;Also a number requiring fixed point representation but how many bits to use?
 02D                             ;
 02D                             ;The way to resolve this is to realise that a multiplication will be
 02D                             ;performed and it would be nice if the +1250 result ended up in a register pair.
 02D                             ;So if we perform a 16x16-bit multiplication such that the upper 16-bits of
 02D                             ;the 32-bit result is the required value, then everything will resolve itself.
 02D                             ;
 02D                             ;Hence the constant required is actually (1250x(2^16))/8191=+10001 (2711 hex).
 02D                             ;
 02D                             ;Using the example 1FFF x 2711 = 04E1F8EF
 02D                             ;   of which the upper 16-bits = 04E1 (+1249 decimal)
 02D                             ;
 02D                             ;Likewise the other limit case is E000 x 2711 = FB1DE000
 02D                             ;   of which the upper 16-bits = FB1D (-1251 decimal)
 02D                             ;
 02D                             ;The values can be made perfect by rounding before truncation
 02D                             ;
 02D  06200                      FETCH s2, ADC0_lsb[00]                  ;Read A/D channel 0 value
 02E  06301                      FETCH s3, ADC0_msb[01]
 02F  00011                      LOAD s0, 11                             ;scaling value for input to A/D converter
 030  00127                      LOAD s1, 27
 031  300F6                      CALL mult_16x16s[0F6]                   ;[s7,s6,s5,s4]=[s3,s2]x[s1,s0]
 032  20506                      SL0 s5                                  ;round value before truncation
 033  1A600                      ADDCY s6, 00
 034  1A700                      ADDCY s7, 00
 035                             ;
 035                             ;The register pair [s7,s6] now holds the binary value
 035                             ;representing the input level to the A/D converter in milli-volts.
 035                             ;This is now displayed on the LCD. Negative values need to be converted to
 035                             ;signed magnitude for display.
 035                             ;
 035  00520                      LOAD s5, 20                             ;Line 2 position 0
 036  30243                      CALL LCD_cursor[243]
 037                             ;CALL disp_AD                        ;display A/D=
 037  12780                      TEST s7, 80                             ;test sign bit of value
 038  3543B                      JUMP NZ, neg_AD[03B]
 039  0052B                      LOAD s5, character_plus[2B]
 03A  34040                      JUMP AD_sign[040]
 03B  0E6FF              neg_AD: XOR s6, FF                              ;complement [s7,s6] to make positive
 03C  0E7FF                      XOR s7, FF
 03D  18601                      ADD s6, 01
 03E  1A700                      ADDCY s7, 00
 03F                             ;LOAD s5, character_minus
 03F  00520                      LOAD s5, character_space[20]
 040  30203             AD_sign: CALL LCD_write_data[203]                ;display sign of value
 041  3007B                      CALL disp_volts[07B]                    ;display 4 digit value as X.XXXv
 042  3019F                      CALL read_from_UART[19F]
 043                             ;
 043                             ;Convert A/D channel 0 value to display the VINA decimal voltage
 043                             ;
 043                             ;The same fundamental technique can be used to convert the 14-bit
 043                             ;A/D value into the level at the VINA input except that two more factors
 043                             ;must be considered.
 043                             ;
 043                             ;The first is that the amplifier inverts and has gain. Therefore the
 043                             ;VINA input level is opposite polarity and could be a smaller deviation
 043                             ;from the mid rail 1.65v reference.
 043                             ;
 043                             ;Secondly, to display the actual voltage level at the VINA terminal
 043                             ;the 1.65v offset must be added.
 043                             ;
 043                             ;The voltage at the VINA input is therefore...
 043                             ;
 043                             ;   VINA = [AD_value x (1.25/(8192 x G))]+1.65
 043                             ;
 043                             ;Following the same methodology as for the A/D value, it means that there
 043                             ;is a set of scaling factors to deal with the negative gain values.
 043                             ;
 043                             ; K = (+1250 x (2^16)) / (8191 x G)
 043                             ;
 043                             ;        G             K     (K Hex)
 043                             ;       -1          -10001   (D8EF)
 043                             ;       -2           -5001   (EC77)
 043                             ;       -5           -2000   (F830)
 043                             ;      -10           -1000   (FC18)
 043                             ;      -20            -500   (FE0C)
 043                             ;      -50            -200   (FF38)
 043                             ;     -100            -100   (FF9C)
 043                             ;
 043  3019F                      CALL read_from_UART[19F]
 044  06200                      FETCH s2, ADC0_lsb[00]                  ;Read A/D channel 0 value
 045  06301                      FETCH s3, ADC0_msb[01]
 046  06404                      FETCH s4, amp_A_gain[04]                ;read A gain and select appropiate gain setting
 047  000EF                      LOAD s0, EF                             ;scaling value for amplifier gain of -1
 048  001D8                      LOAD s1, D8
 049  14401                      COMPARE s4, 01
 04A  35061                      JUMP Z, mult_VINA[061]
 04B  00077                      LOAD s0, 77                             ;scaling value for amplifier gain of -2
 04C  001EC                      LOAD s1, EC
 04D  14402                      COMPARE s4, 02
 04E  35061                      JUMP Z, mult_VINA[061]
 04F  00030                      LOAD s0, 30                             ;scaling value for amplifier gain of -5
 050  001F8                      LOAD s1, F8
 051  14403                      COMPARE s4, 03
 052  35061                      JUMP Z, mult_VINA[061]
 053  00018                      LOAD s0, 18                             ;scaling value for amplifier gain of -10
 054  001FC                      LOAD s1, FC
 055  14405                      COMPARE s4, 05
 056  35061                      JUMP Z, mult_VINA[061]
 057  0000C                      LOAD s0, 0C                             ;scaling value for amplifier gain of -20
 058  001FE                      LOAD s1, FE
 059  14406                      COMPARE s4, 06
 05A  35061                      JUMP Z, mult_VINA[061]
 05B  00038                      LOAD s0, 38                             ;scaling value for amplifier gain of -50
 05C  001FF                      LOAD s1, FF
 05D  14401                      COMPARE s4, 01
 05E  35061                      JUMP Z, mult_VINA[061]
 05F  0009C                      LOAD s0, 9C                             ;scaling value for amplifier gain of -100
 060  001FF                      LOAD s1, FF
 061  300F6           mult_VINA: CALL mult_16x16s[0F6]                   ;[s7,s6,s5,s4]=[s3,s2]x[s1,s0]
 062  20506                      SL0 s5                                  ;round value before truncation
 063  1A600                      ADDCY s6, 00
 064  1A700                      ADDCY s7, 00
 065  18672                      ADD s6, VREF_lsb[72]                    ;add 1.65v offset represented at 1650 (0672 hex)
 066  1A706                      ADDCY s7, VREF_msb[06]
 067                             ;
 067                             ;The register pair [s7,s6] now holds the binary value
 067                             ;representing the VINA input level in milli-volts.
 067                             ;This must be a positive value due to the offset of 1.65v
 067                             ;being greater than the maximum relative range of -1.25v to +1.25v.
 067                             ;This binary value can now be converted to a decimal digits
 067                             ;and displayed on the LCD.
 067                             ;
 067                             ;If the A/D value is maximum negative (E000) or maximum positive (1FFF)
 067                             ;then an indication of the actual value being applied being greater or
 067                             ;less than that computed will be made.
 067                             ;
 067  3019F                      CALL read_from_UART[19F]
 068  00517                      LOAD s5, 17                             ;Line 1 position 7
 069  30243                      CALL LCD_cursor[243]
 06A                             ;CALL disp_VA                        ;display VA=
 06A                             ;call delay_1ms
 06A                             ;call send_test
 06A                             ;call delay_20ms
 06A                             ;call read_from_UART
 06A  301E0                      CALL delay_20ms[1E0]
 06B  3019F                      CALL read_from_UART[19F]
 06C  06200                      FETCH s2, ADC0_lsb[00]                  ;Read A/D channel 0 value
 06D  06301                      FETCH s3, ADC0_msb[01]
 06E  143E0                      COMPARE s3, E0                          ;test for maximum negative
 06F  35474                      JUMP NZ, test_max_pos[074]
 070  14200                      COMPARE s2, 00
 071  35474                      JUMP NZ, test_max_pos[074]
 072  0053E                      LOAD s5, character_greater_than[3E]     ;display >
 073                             ;CALL LCD_write_data
 073  34079                      JUMP disp_VINA_volts[079]
 074  1431F        test_max_pos: COMPARE s3, 1F                          ;test for maximum positive
 075  35479                      JUMP NZ, disp_VINA_volts[079]
 076  142FF                      COMPARE s2, FF
 077  35479                      JUMP NZ, disp_VINA_volts[079]
 078                             ;LOAD s5, character_less_than        ;display <
 078  30203                      CALL LCD_write_data[203]
 079  3007B     disp_VINA_volts: CALL disp_volts[07B]                    ;display 4 digit value as X.XXXv
 07A  34014                      JUMP warm_start[014]
 07B                             ;
 07B                             ;
 07B                             ;**************************************************************************************
 07B                             ;Display voltage level at in the form X.XXX on the LCD at current cursor position
 07B                             ;**************************************************************************************
 07B                             ;
 07B                             ;Value to be displayed must be unsigned (positive) in the
 07B                             ;[s7,s6] register pair. Only the lower 4 digits are displayed.
 07B                             ;
 07B  30114          disp_volts: CALL integer16_to_BCD[114]              ;convert [s7,s6] to BCD in scratch pad memory
 07C  0650A                      FETCH s5, decimal3[0A]
 07D  18530                      ADD s5, 30                              ;convert to ASCII
 07E  01B50                      LOAD uart_data[sB], s5
 07F  301AB                      CALL send_to_UART[1AB]
 080                             ;LOAD s5, uart_data
 080                             ;CALL LCD_write_data
 080  3019F                      CALL read_from_UART[19F]
 081                             ;CALL LCD_write_data
 081  0052E                      LOAD s5, character_stop[2E]
 082  01B50                      LOAD uart_data[sB], s5
 083  301AB                      CALL send_to_UART[1AB]
 084                             ;CALL LCD_write_data
 084  06509                      FETCH s5, decimal2[09]
 085  18530                      ADD s5, 30                              ;convert to ASCII
 086  01B50                      LOAD uart_data[sB], s5
 087  301AB                      CALL send_to_UART[1AB]
 088                             ;     ;CALL LCD_write_data
 088  06508                      FETCH s5, decimal1[08]
 089  18530                      ADD s5, 30                              ;convert to ASCII
 08A  01B50                      LOAD uart_data[sB], s5
 08B  301AB                      CALL send_to_UART[1AB]
 08C                             ;CALL LCD_write_data
 08C  06507                      FETCH s5, decimal0[07]
 08D  18530                      ADD s5, 30                              ;convert to ASCII
 08E  01B50                      LOAD uart_data[sB], s5
 08F  301AB                      CALL send_to_UART[1AB]
 090                             ;CALL LCD_write_data
 090  00520                      LOAD s5, character_space[20]            ;ensure next position is cleared
 091  01B50                      LOAD uart_data[sB], s5
 092  301AB                      CALL send_to_UART[1AB]
 093  0050D                      LOAD s5, character_CR[0D]
 094  01B50                      LOAD uart_data[sB], s5
 095  301AB                      CALL send_to_UART[1AB]
 096                             ;CALL LCD_write_data
 096  2A000                      RETURN
 097                             ;
 097                             ;**************************************************************************************
 097                             ;Changing amplifier gain using press buttons
 097                             ;**************************************************************************************
 097                             ;
 097                             ;Possible gain values are
 097                             ;   Gain   Amplifier
 097                             ;            code
 097                             ;    -1        1
 097                             ;    -2        2
 097                             ;    -5        3
 097                             ;   -10        4
 097                             ;   -20        5
 097                             ;   -50        6
 097                             ;  -100        7
 097                             ;
 097  3019F                      CALL read_from_UART[19F]
 098  3C000       gain_increase: DISABLE INTERRUPT                       ;stop normal operation
 099  06004                      FETCH s0, amp_A_gain[04]                ;read current gain
 09A  18001                      ADD s0, 01
 09B  14008                      COMPARE s0, 08                          ;test for too big
 09C  354A4                      JUMP NZ, new_gain_set[0A4]
 09D  00007                      LOAD s0, 07                             ;maximum gain
 09E  340A4                      JUMP new_gain_set[0A4]
 09F  3C000       gain_decrease: DISABLE INTERRUPT                       ;stop normal operation
 0A0  06004                      FETCH s0, amp_A_gain[04]                ;read current gain
 0A1  1C001                      SUB s0, 01
 0A2  354A4                      JUMP NZ, new_gain_set[0A4]
 0A3  00001                      LOAD s0, 01                             ;minimum gain
 0A4  2E004        new_gain_set: STORE s0, amp_A_gain[04]                ;store new value
 0A5  06205                      FETCH s2, amp_B_gain[05]                ;form the amplifier control byte
 0A6  20206                      SL0 s2                                  ;B amplifier set by upper 4 bits
 0A7  20206                      SL0 s2
 0A8  20206                      SL0 s2
 0A9  20206                      SL0 s2
 0AA  0D200                      OR s2, s0                               ;A amplifier set by lower
 0AB  30134                      CALL set_amp[134]                       ;set SPI amplifier
 0AC                             ;display gain setting on LCD
 0AC  00510                      LOAD s5, 10                             ;Line 1 position 0
 0AD  30243                      CALL LCD_cursor[243]
 0AE  00547                      LOAD s5, character_G[47]
 0AF  30203                      CALL LCD_write_data[203]
 0B0  0053D                      LOAD s5, character_equals[3D]
 0B1  30203                      CALL LCD_write_data[203]
 0B2  0052D                      LOAD s5, character_minus[2D]
 0B3  30203                      CALL LCD_write_data[203]
 0B4  06004                      FETCH s0, amp_A_gain[04]                ;read A gain setting
 0B5  14001                      COMPARE s0, 01                          ;determine actual gain value
 0B6  354BE                      JUMP NZ, test_A2[0BE]
 0B7  00531                      LOAD s5, character_1[31]                ;gain is -1
 0B8  30203                      CALL LCD_write_data[203]
 0B9  00520                      LOAD s5, character_space[20]
 0BA  30203                      CALL LCD_write_data[203]
 0BB  00520                      LOAD s5, character_space[20]
 0BC  30203                      CALL LCD_write_data[203]
 0BD  340F1                      JUMP wait_no_press[0F1]
 0BE  14002             test_A2: COMPARE s0, 02
 0BF  354C7                      JUMP NZ, test_A3[0C7]
 0C0  00532                      LOAD s5, character_2[32]                ;gain is -2
 0C1  30203                      CALL LCD_write_data[203]
 0C2  00520                      LOAD s5, character_space[20]
 0C3  30203                      CALL LCD_write_data[203]
 0C4  00520                      LOAD s5, character_space[20]
 0C5  30203                      CALL LCD_write_data[203]
 0C6  340F1                      JUMP wait_no_press[0F1]
 0C7  14003             test_A3: COMPARE s0, 03
 0C8  354D0                      JUMP NZ, test_A4[0D0]
 0C9  00535                      LOAD s5, character_5[35]                ;gain is -5
 0CA  30203                      CALL LCD_write_data[203]
 0CB  00520                      LOAD s5, character_space[20]
 0CC  30203                      CALL LCD_write_data[203]
 0CD  00520                      LOAD s5, character_space[20]
 0CE  30203                      CALL LCD_write_data[203]
 0CF  340F1                      JUMP wait_no_press[0F1]
 0D0  14004             test_A4: COMPARE s0, 04
 0D1  354D9                      JUMP NZ, test_A5[0D9]
 0D2  00531                      LOAD s5, character_1[31]                ;gain is -10
 0D3  30203                      CALL LCD_write_data[203]
 0D4  00530                      LOAD s5, character_0[30]
 0D5  30203                      CALL LCD_write_data[203]
 0D6  00520                      LOAD s5, character_space[20]
 0D7  30203                      CALL LCD_write_data[203]
 0D8  340F1                      JUMP wait_no_press[0F1]
 0D9  14005             test_A5: COMPARE s0, 05
 0DA  354E2                      JUMP NZ, test_A6[0E2]
 0DB  00532                      LOAD s5, character_2[32]                ;gain is -20
 0DC  30203                      CALL LCD_write_data[203]
 0DD  00530                      LOAD s5, character_0[30]
 0DE  30203                      CALL LCD_write_data[203]
 0DF  00520                      LOAD s5, character_space[20]
 0E0  30203                      CALL LCD_write_data[203]
 0E1  340F1                      JUMP wait_no_press[0F1]
 0E2  14006             test_A6: COMPARE s0, 06
 0E3  354EB                      JUMP NZ, gain_A7[0EB]
 0E4  00535                      LOAD s5, character_5[35]                ;gain is -50
 0E5  30203                      CALL LCD_write_data[203]
 0E6  00530                      LOAD s5, character_0[30]
 0E7  30203                      CALL LCD_write_data[203]
 0E8  00520                      LOAD s5, character_space[20]
 0E9  30203                      CALL LCD_write_data[203]
 0EA  340F1                      JUMP wait_no_press[0F1]
 0EB  00531             gain_A7: LOAD s5, character_1[31]                ;gain is -100
 0EC  30203                      CALL LCD_write_data[203]
 0ED  00530                      LOAD s5, character_0[30]
 0EE  30203                      CALL LCD_write_data[203]
 0EF  00530                      LOAD s5, character_0[30]
 0F0  30203                      CALL LCD_write_data[203]
 0F1  301E0       wait_no_press: CALL delay_20ms[1E0]                    ;delay to help avoid switch bounce
 0F2  04000                      INPUT s0, switch_port[00]               ;check for release of press buttons
 0F3  12005                      TEST s0, 05                             ;north and south buttons
 0F4  354F1                      JUMP NZ, wait_no_press[0F1]
 0F5  34014                      JUMP warm_start[014]
 0F6                             ;
 0F6                             ;**************************************************************************************
 0F6                             ;16-bit by 16-bit Signed multiplier
 0F6                             ;**************************************************************************************
 0F6                             ;
 0F6                             ;16 bit signed multiplication using shift and add technique.
 0F6                             ;The full precision 32-bit product is returned.
 0F6                             ;
 0F6                             ;The key to signed multiplication is to think of all bits of the second operand
 0F6                             ;[s1,s0] as being positive except for the most significant bit. This means that
 0F6                             ;the first operand is added to the result in all cases when there is a '1' in the
 0F6                             ;second operand except for the MSB case when the first operand is subtracted if there
 0F6                             ;is a '1'.
 0F6                             ;
 0F6                             ;[s7,s6,s5,s4]=[s3,s2]x[s1,s0]
 0F6                             ;
 0F6                             ;Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sA
 0F6                             ;
 0F6  00700         mult_16x16s: LOAD s7, 00                             ;clear accumulator
 0F7  00600                      LOAD s6, 00
 0F8  00500                      LOAD s5, 00                             ;Set bit 14 to act as a bit shift counter
 0F9  00400                      LOAD s4, 00
 0FA  00800                      LOAD s8, 00                             ;sign extend [s3,s2] to form [s9,s8,s3,s2]
 0FB  12380                      TEST s3, 80                             ;test sign of first operand
 0FC  350FE                      JUMP Z, m16s_pos[0FE]
 0FD  008FF                      LOAD s8, FF
 0FE  01980            m16s_pos: LOAD s9, s8                             ;[s9,s8,s3,s2]=0000xxxx or FFFFxxxx as required
 0FF  00A0F                      LOAD sA, 0F                             ;15 positive shift and add operations to perform
 100  2010E           m16s_loop: SR0 s1                                  ;shift right operand [s1,s0]
 101  20008                      SRA s0
 102  35D07                      JUMP NC, m16s_noadd[107]                ;test for a '1'
 103  19420                      ADD s4, s2                              ;32-bit addition [s7,s6,s5,s4]=[s7,s6,s5,s4]+[s9,s8,s3,s2]
 104  1B530                      ADDCY s5, s3
 105  1B680                      ADDCY s6, s8
 106  1B790                      ADDCY s7, s9
 107  20206          m16s_noadd: SL0 s2                                  ;multiply first operand by 2
 108  20300                      SLA s3
 109  20800                      SLA s8
 10A  20900                      SLA s9
 10B  1CA01                      SUB sA, 01
 10C  35500                      JUMP NZ, m16s_loop[100]                 ;move to next unsigned bit
 10D  12001                      TEST s0, 01                             ;test sign bit of operand [s1,s0]
 10E  35D13                      JUMP NC, m16s_nosub[113]
 10F  1D420                      SUB s4, s2                              ;32-bit subtraction [s7,s6,s5,s4]=[s7,s6,s5,s4]-[s9,s8,s3,s2]
 110  1F530                      SUBCY s5, s3
 111  1F680                      SUBCY s6, s8
 112  1F790                      SUBCY s7, s9
 113  2A000          m16s_nosub: RETURN
 114                             ;
 114                             ;
 114                             ;
 114                             ;**************************************************************************************
 114                             ;16-bit positive integer to 5 digit decimal conversion
 114                             ;**************************************************************************************
 114                             ;
 114                             ;Convert the 16 bit value in register set [s7,s6]
 114                             ;into the BCD decimal equivalent located in the scratch pad memory
 114                             ;locations 'decimal0' to 'decimal4' which must be in ascending locations.
 114                             ;
 114                             ;Register set [s9,s8,s7,s6] are preserved.
 114                             ;
 114                             ;
 114                             ;Each digit is formed in turn starting with the least significant.
 114                             ;
 114                             ;Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8
 114                             ;
 114  00005    integer16_to_BCD: LOAD s0, 05                             ;5 digits to be formed from value up to 65535
 115  00807                      LOAD s8, decimal0[07]                   ;pointer for LS-Digit
 116  3011C     int_to_BCD_loop: CALL divide_16bit_by_10[11C]            ;[s7,s6]=[s7,s6]/10  with remainder in s4
 117  2F480                      STORE s4, (s8)                          ;remainder becomes digit value
 118  18801                      ADD s8, 01                              ;move to next most significant digit
 119  1C001                      SUB s0, 01                              ;one less digit to compute
 11A  35516                      JUMP NZ, int_to_BCD_loop[116]
 11B  2A000                      RETURN
 11C                             ;
 11C                             ;Divide 16-bit binary integer by 10
 11C                             ;
 11C                             ;The value to be divided is held in register set [s7,s6]
 11C                             ;and this is where the result is returned to.
 11C                             ;
 11C                             ;At then end of the integer division the remainder in the range 0 to 9
 11C                             ;will be in register s4.
 11C                             ;
 11C                             ;Registers used s1,s2,s3,s4,s5,s6,s7
 11C                             ;Other registers are used but are preserved
 11C                             ;
 11C  01460  divide_16bit_by_10: LOAD s4, s6                             ;copy input value to [s5,s4]
 11D  01570                      LOAD s5, s7
 11E  00600                      LOAD s6, 00                             ;clear result
 11F  00700                      LOAD s7, 00
 120  00200                      LOAD s2, 00                             ;initialise '10' value into msb's of set [s3,s2]
 121  003A0                      LOAD s3, A0
 122  0010D                      LOAD s1, 0D                             ;13 subtract and shift iterations to be performed
 123  1D420          div10_loop: SUB s4, s2                              ;perform 16-bit subtract [s5,s4]-[s3,s2]
 124  1F530                      SUBCY s5, s3
 125  35928                      JUMP C, div10_restore[128]
 126  20607                      SL1 s6                                  ;shift '1' into result because subtract was possible
 127  3412B                      JUMP div10_shifts[12B]
 128  19420       div10_restore: ADD s4, s2                              ;perform 32-bit addition [s5,s4]+[s3,s2]
 129  1B530                      ADDCY s5, s3                            ;to restore value
 12A  20606                      SL0 s6                                  ;shift '0' into result because subtract was not possible
 12B  20700        div10_shifts: SLA s7                                  ;complete 16-bit shift left
 12C  2030E                      SR0 s3                                  ;divide '10' value by 2 (shift right 1 place)
 12D  20208                      SRA s2
 12E  1C101                      SUB s1, 01                              ;count iterations
 12F  35523                      JUMP NZ, div10_loop[123]
 130  2A000                      RETURN
 131                             ;
 131                             ;
 131                             ;**************************************************************************************
 131                             ;SPI communication routines for Spartan-3E Starter Kit
 131                             ;**************************************************************************************
 131                             ;
 131                             ;These routines will work with two output ports and one input port which should be
 131                             ;defined as follows using CONSTANT directives.
 131                             ;   (replace 'pp' with appropriate port address in each case)
 131                             ;In the list of CONSTANT directives, there are ports associated with all the SPI devices
 131                             ;provided on the board. Even if some devices are not used, it is vital that the remaining
 131                             ;devices are disabled. Leaving all signals connected and use of these routines will ensure
 131                             ;that all other devices are disabled when communicating with a particular device.
 131                             ;
 131                             ;
 131                             ;
 131                             ;CONSTANT SPI_control_port, pp       ;SPI clock and chip selects
 131                             ;CONSTANT SPI_sck, 01                ;                  SCK - bit0
 131                             ;CONSTANT SPI_rom_cs, 02             ;    serial rom select - bit1
 131                             ;CONSTANT SPI_spare_control, 04      ;                spare - bit2
 131                             ;CONSTANT SPI_amp_cs, 08             ;     amplifier select - bit3
 131                             ;CONSTANT SPI_adc_conv, 10           ;          A/D convert - bit4
 131                             ;CONSTANT SPI_dac_cs, 20             ;           D/A select - bit5
 131                             ;CONSTANT SPI_amp_shdn, 40           ;       amplifier SHDN - bit6
 131                             ;CONSTANT SPI_dac_clr, 80            ;            D/A clear - bit7
 131                             ;
 131                             ;CONSTANT SPI_output_port, pp        ;SPI data output
 131                             ;CONSTANT SPI_sdo, 80                ;   SDO - bit7
 131                             ;
 131                             ;CONSTANT SPI_input_port, pp         ;SPI data input
 131                             ;CONSTANT SPI_sdi, 80                ;             SDI - bit7
 131                             ;CONSTANT SPI_amp_sdi, 40            ;   amplifier SDI - bit6
 131                             ;
 131                             ;
 131                             ;
 131                             ;
 131                             ;Initialise SPI bus
 131                             ;
 131                             ;This routine should be used to initialise the SPI bus.
 131                             ;The SCK clock is made low.
 131                             ;Device selections are made inactive as follows
 131                             ;   SPI_sck      = 0      Clock is Low (required)
 131                             ;   SPI_rom_cs   = 1      Deselect ROM
 131                             ;   spare        = 1      spare control bit
 131                             ;   SPI_amp_cs   = 1      Deselect amplifier
 131                             ;   SPI_adc_conv = 0      A/D convert ready to apply positive pulse
 131                             ;   SPI_dac_cs   = 1      Deselect D/A
 131                             ;   SPI_amp_shdn = 0      Amplifier active and available
 131                             ;   SPI_dac_clr  = 1      D/A clear off
 131                             ;
 131  000AE            SPI_init: LOAD s0, AE                             ;normally AE
 132  2C008                      OUTPUT s0, SPI_control_port[08]
 133  2A000                      RETURN
 134                             ;
 134                             ;
 134                             ;
 134                             ;
 134                             ;**************************************************************************************
 134                             ;SPI communication routines for Programmable Amplifier
 134                             ;**************************************************************************************
 134                             ;
 134                             ;
 134                             ;Set the A and B channel gain of the Dual Amplifier (LTC6912-1).
 134                             ;
 134                             ;The gain value should be provided in the s2 register with the upper nibble
 134                             ;defining the gain for the B channel and lower nibble the gain for the A channel.
 134                             ; 0000 = 0 hex = Gain  0 with input hi-Z and output driving
 134                             ; 0001 = 1 hex = Gain -1
 134                             ; 0010 = 2 hex = Gain -2
 134                             ; 0011 = 3 hex = Gain -5
 134                             ; 0100 = 4 hex = Gain -10
 134                             ; 0101 = 5 hex = Gain -20
 134                             ; 0110 = 6 hex = Gain -50
 134                             ; 0111 = 7 hex = Gain -100
 134                             ; 1000 = 8 hex = software shutdown (power on default). Hi-Z output.
 134                             ;
 134                             ;On return, the s2, register will contain the response from the LTC6912-1 amplifier.
 134                             ;This will be the same format and indicate the previous setting of the amplifier.
 134                             ;The response is obtained from the dedicated AMP_SDI signal since the LTC6912 output
 134                             ;is always active and can not be on a shared SPI bus.
 134                             ;
 134  30131             set_amp: CALL SPI_init[131]                      ;ensure known state of bus and s0 register
 135  0E008                      XOR s0, SPI_amp_cs[08]                  ;select low on Amplifier chip select
 136  2C008                      OUTPUT s0, SPI_control_port[08]
 137  00108                      LOAD s1, 08                             ;8-bits to transmit and receive
 138  2C204    next_amp_SPI_bit: OUTPUT s2, SPI_output_port[04]          ;output data bit
 139  0E001                      XOR s0, SPI_sck[01]                     ;clock High (bit0)
 13A  2C008                      OUTPUT s0, SPI_control_port[08]         ;drive clock High
 13B  04301                      INPUT s3, SPI_input_port[01]            ;read input bit
 13C  12340                      TEST s3, SPI_amp_sdi[40]                ;detect state of received bit
 13D  20200                      SLA s2                                  ;shift new data into result and move to next transmit bit
 13E  0E001                      XOR s0, SPI_sck[01]                     ;clock Low (bit0)
 13F  2C008                      OUTPUT s0, SPI_control_port[08]         ;drive clock Low
 140  1C101                      SUB s1, 01                              ;count bits
 141  35538                      JUMP NZ, next_amp_SPI_bit[138]          ;repeat until finished
 142  0E008                      XOR s0, SPI_amp_cs[08]                  ;deselect the amplifier
 143  2C008                      OUTPUT s0, SPI_control_port[08]
 144  2A000                      RETURN
 145                             ;
 145                             ;
 145                             ;
 145                             ;**************************************************************************************
 145                             ;SPI communication routines for A/D Converter
 145                             ;**************************************************************************************
 145                             ;
 145                             ;
 145                             ;
 145                             ;Sample A/D converter (LTC1407A-1) and return results.
 145                             ;
 145                             ;Note there is a latency of one read to obtain the value. Each read results in the
 145                             ;the analogue inputs being sampled and converted but this value will only be transmitted
 145                             ;during the next read and conversion cycle.
 145                             ;
 145                             ;The results are returned as follows.
 145                             ;   Channel 0 in registers [s9,s8]
 145                             ;   Channel 1 in registers [s7,s6]
 145                             ;Where each is a 14-bit twos complement value sign extended to 16-bits.
 145                             ;
 145                             ;Each 14-bit value represents the analogue voltage in the range -1.25v to +1.25v
 145                             ;relative to the reference voltage of 1.65v (3.3v/2). Hence the actual input voltage
 145                             ;range is 0.4v to 2.9v. Since the input to the A/D is supplied via the programmable
 145                             ;amplifier, the VINA and VINB inputs are inverted and may cover a smaller range if                       ;
 145                             ;desired.
 145                             ;
 145                             ;Examples
 145                             ;   VINA = 0.65v with gain=-1 means input to A/D = 2.65v
 145                             ;      This is equivalent to +1.00v which is value (8192/1.25)*1 = 6553 (1999 hex)
 145                             ;
 145                             ;   VINA = 2.65v with gain=-1 means input to A/D = 0.65v
 145                             ;      This is equivalent to -1.00v which is value (2048/1.25)*-1 = -6553 (E667 hex)
 145                             ;
 145                             ;
 145                             ;Although the A/D converter claims to be an SPI device, it really
 145                             ;does not conform to the normal specification of the 4-wire interface.
 145                             ;
 145                             ;Firstly the CONV signal is only pulsed High and does not behave like
 145                             ;a normal active low select signal. Secondly, the communication is
 145                             ;34 bits which does not fit a byte boundary, and thirdly, the data output
 145                             ;to its SDO pin changes as a result of rising edges of SCK clock which
 145                             ;is not the same as the falling edge used by other devices.
 145                             ;
 145  30131            adc_read: CALL SPI_init[131]                      ;ensure known state of bus and s0 register
 146  0E010                      XOR s0, SPI_adc_conv[10]                ;Pulse AD-CONV High to take sample and start
 147  2C008                      OUTPUT s0, SPI_control_port[08]         ;  conversion and transmission of data.
 148  0E010                      XOR s0, SPI_adc_conv[10]                ;AD-CONV Low
 149  2C008                      OUTPUT s0, SPI_control_port[08]
 14A  00122                      LOAD s1, 22                             ;34 clocks to read all data
 14B  0E001        next_adc_bit: XOR s0, SPI_sck[01]                     ;clock High (bit0)
 14C  2C008                      OUTPUT s0, SPI_control_port[08]         ;drive clock High
 14D  0E001                      XOR s0, SPI_sck[01]                     ;clock Low (bit0)
 14E  2C008                      OUTPUT s0, SPI_control_port[08]         ;drive clock Low
 14F  04301                      INPUT s3, SPI_input_port[01]            ;read input bit
 150  12380                      TEST s3, SPI_sdi[80]                    ;detect state of received bit
 151  20600                      SLA s6                                  ;shift new data into result registers
 152  20700                      SLA s7
 153  20800                      SLA s8
 154  20900                      SLA s9
 155  1C101                      SUB s1, 01                              ;count bits
 156  3554B                      JUMP NZ, next_adc_bit[14B]              ;repeat until finished
 157  2090A                      SRX s9                                  ;sign extend 14-bit result in [s9,s8]
 158  20808                      SRA s8
 159  2090A                      SRX s9
 15A  20808                      SRA s8
 15B  2070A                      SRX s7                                  ;sign extend 14-bit result in [s7,s6]
 15C  20608                      SRA s6
 15D  2070A                      SRX s7
 15E  20608                      SRA s6
 15F  2A000                      RETURN
 160                             ;
 160                             ;
 160                             ;**************************************************************************************
 160                             ;LCD text messages
 160                             ;**************************************************************************************
 160                             ;
 160                             ;
 160                             ;Display 'PicoBlaze' on LCD at current cursor position
 160                             ;
 160                             ;
 160  00553      disp_PicoBlaze: LOAD s5, character_S[53]
 161  30203                      CALL LCD_write_data[203]
 162  0056D                      LOAD s5, character_m[6D]
 163  30203                      CALL LCD_write_data[203]
 164  00561                      LOAD s5, character_a[61]
 165  30203                      CALL LCD_write_data[203]
 166  00572                      LOAD s5, character_r[72]
 167  30203                      CALL LCD_write_data[203]
 168  00574                      LOAD s5, character_t[74]
 169  30203                      CALL LCD_write_data[203]
 16A  00562                      LOAD s5, character_b[62]
 16B  30203                      CALL LCD_write_data[203]
 16C  0056F                      LOAD s5, character_o[6F]
 16D  30203                      CALL LCD_write_data[203]
 16E  00561                      LOAD s5, character_a[61]
 16F  30203                      CALL LCD_write_data[203]
 170  00572                      LOAD s5, character_r[72]
 171  30203                      CALL LCD_write_data[203]
 172  00564                      LOAD s5, character_d[64]
 173  30203                      CALL LCD_write_data[203]
 174  2A000                      RETURN
 175                             ;
 175                             ;
 175                             ;Display 'ADC Control' on LCD at current cursor position
 175                             ;
 175                             ;
 175  00549    disp_ADC_Control: LOAD s5, character_I[49]
 176  30203                      CALL LCD_write_data[203]
 177  0054F                      LOAD s5, character_O[4F]
 178  30203                      CALL LCD_write_data[203]
 179  00520                      LOAD s5, character_space[20]
 17A  30203                      CALL LCD_write_data[203]
 17B  00543                      LOAD s5, character_C[43]
 17C  30203                      CALL LCD_write_data[203]
 17D  0056F                      LOAD s5, character_o[6F]
 17E  30203                      CALL LCD_write_data[203]
 17F  0056E                      LOAD s5, character_n[6E]
 180  30203                      CALL LCD_write_data[203]
 181  00574                      LOAD s5, character_t[74]
 182  30203                      CALL LCD_write_data[203]
 183  00572                      LOAD s5, character_r[72]
 184  30203                      CALL LCD_write_data[203]
 185  0056F                      LOAD s5, character_o[6F]
 186  30203                      CALL LCD_write_data[203]
 187  0056C                      LOAD s5, character_l[6C]
 188  30203                      CALL LCD_write_data[203]
 189  2A000                      RETURN
 18A                             ;
 18A                             ;
 18A                             ;Display 'VA=' on LCD at current cursor position
 18A                             ;
 18A                             ;
 18A  00556             disp_VA: LOAD s5, character_V[56]
 18B  30203                      CALL LCD_write_data[203]
 18C  00541                      LOAD s5, character_A[41]
 18D  30203                      CALL LCD_write_data[203]
 18E  0053D                      LOAD s5, character_equals[3D]
 18F  30203                      CALL LCD_write_data[203]
 190  2A000                      RETURN
 191                             ;
 191                             ;
 191                             ;Display 'A/D' on LCD at current cursor position
 191                             ;
 191                             ;
 191  00541             disp_AD: LOAD s5, character_A[41]
 192  30203                      CALL LCD_write_data[203]
 193  0052F                      LOAD s5, character_divide[2F]
 194  30203                      CALL LCD_write_data[203]
 195  00544                      LOAD s5, character_D[44]
 196  30203                      CALL LCD_write_data[203]
 197  0053D                      LOAD s5, character_equals[3D]
 198  30203                      CALL LCD_write_data[203]
 199  2A000                      RETURN
 19A                             ;
 19A                             ;
 19A                             ;
 19A                  send_test: 
 19A  00B75                      LOAD uart_data[sB], character_u[75]     ;ADC0_msb
 19B  301AB                      CALL send_to_UART[1AB]
 19C  00B61                      LOAD uart_data[sB], character_a[61]     ;ADC0_lsb
 19D  301AB                      CALL send_to_UART[1AB]
 19E  2A000                      RETURN
 19F                             ; ==========================================================================================
 19F                             ;     UART routines
 19F             read_from_UART: 
 19F  00E02                      LOAD sE, 02
 1A0  04004          uart_again: INPUT s0, UART_status_port[04]
 1A1  12004                      TEST s0, rx_data_present[04]
 1A2                             ;JUMP      Z, read_from_uart_end
 1A2  04106                      INPUT s1, UART_read_port[06]
 1A3  01B10                      LOAD uart_data[sB], s1
 1A4  00574                      LOAD s5, character_t[74]
 1A5  30203                      CALL LCD_write_data[203]
 1A6  015B0                      LOAD s5, uart_data[sB]
 1A7  30203                      CALL LCD_write_data[203]
 1A8  1CE01                      SUB sE, 01
 1A9  355A0                      JUMP NZ, uart_again[1A0]
 1AA         read_from_uart_end: 
 1AA  2A000                      RETURN
 1AB               send_to_UART: 
 1AB  04004                      INPUT s0, UART_status_port[04]
 1AC  12002                      TEST s0, tx_full[02]
 1AD  355AB                      JUMP NZ, send_to_UART[1AB]
 1AE  010B0                      LOAD s0, uart_data[sB]
 1AF  2C001                      OUTPUT s0, UART_write_port[01]
 1B0  2A000                      RETURN
 1B1                             ; ==========================================================================================
 1B1                             ; Transmit ASCII string to UART
 1B1                             ;
 1B1                             ; An ASCII string must be provided in scratch pad memory commencing at the
 1B1                             ; location specified by a  named 'string_start'. The string must
 1B1                             ; end with a carriage return and LF.
 1B1                             ;
 1B1                             ; Registers used s1 and 'uart_data'.
 1B1                             ; s0 is then used in subroutine 'send_to_UART'
 1B1                             ;
 1B1            transmit_string: 
 1B1  00110                      LOAD s1, string_start[10]               ; locate start of string
 1B2               next_char_tx: 
 1B2  07B10                      FETCH uart_data[sB], (s1)               ; read character from memory
 1B3  301AB                      CALL send_to_UART[1AB]                  ; transmit character
 1B4  14B0A                      COMPARE uart_data[sB], character_LF[0A] ; test for last character
 1B5  2B000                      RETURN Z
 1B6  18101                      ADD s1, 01                              ; move to next character
 1B7  341B2                      JUMP next_char_tx[1B2]
 1B8                             ;**************************************************************************************
 1B8                             ;Value to ASCII Conversions and LCD display
 1B8                             ;**************************************************************************************
 1B8                             ;
 1B8                             ;Convert hexadecimal value provided in register s0 into ASCII characters
 1B8                             ;
 1B8                             ;The value provided must can be any value in the range 00 to FF and will be converted into
 1B8                             ;two ASCII characters.
 1B8                             ;     The upper nibble will be represented by an ASCII character returned in register s2.
 1B8                             ;     The lower nibble will be represented by an ASCII character returned in register s1.
 1B8                             ;
 1B8                             ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
 1B8                             ;added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
 1B8                             ;hexadecimal requiring a further addition of 07 to the 30 already added.
 1B8                             ;
 1B8                             ;Registers used s0, s1 and s2.
 1B8                             ;
 1B8  01100   hex_byte_to_ASCII: LOAD s1, s0                             ;remember value supplied
 1B9  2000E                      SR0 s0                                  ;isolate upper nibble
 1BA  2000E                      SR0 s0
 1BB  2000E                      SR0 s0
 1BC  2000E                      SR0 s0
 1BD  301C4                      CALL hex_to_ASCII[1C4]                  ;convert
 1BE  01200                      LOAD s2, s0                             ;upper nibble value in s2
 1BF  01010                      LOAD s0, s1                             ;restore complete value
 1C0  0A00F                      AND s0, 0F                              ;isolate lower nibble
 1C1  301C4                      CALL hex_to_ASCII[1C4]                  ;convert
 1C2  01100                      LOAD s1, s0                             ;lower nibble value in s1
 1C3  2A000                      RETURN
 1C4                             ;
 1C4                             ;Convert hexadecimal value provided in register s0 into ASCII character
 1C4                             ;
 1C4                             ;Register used s0
 1C4                             ;
 1C4  1C00A        hex_to_ASCII: SUB s0, 0A                              ;test if value is in range 0 to 9
 1C5  359C7                      JUMP C, number_char[1C7]
 1C6  18007                      ADD s0, 07                              ;ASCII char A to F in range 41 to 46
 1C7  1803A         number_char: ADD s0, 3A                              ;ASCII char 0 to 9 in range 30 to 40
 1C8  2A000                      RETURN
 1C9                             ;
 1C9                             ;
 1C9                             ;Display the two character HEX value of the register contents 's0' on
 1C9                             ;the LCD display at the current cursor position.
 1C9                             ;
 1C9                             ;Registers used s0, s1, s2, s4, s5, s6
 1C9                             ;
 1C9  301B8       disp_hex_byte: CALL hex_byte_to_ASCII[1B8]
 1CA  01610                      LOAD s6, s1                             ;remember lower hex character
 1CB  01520                      LOAD s5, s2                             ;display upper hex character
 1CC  01B50                      LOAD uart_data[sB], s5
 1CD  301AB                      CALL send_to_UART[1AB]
 1CE                             ;CALL LCD_write_data
 1CE  01560                      LOAD s5, s6                             ;display lower hex character
 1CF  01B50                      LOAD uart_data[sB], s5
 1D0  301AB                      CALL send_to_UART[1AB]
 1D1                             ;CALL LCD_write_data
 1D1  2A000                      RETURN
 1D2                             ;
 1D2                             ;
 1D2                             ;**************************************************************************************
 1D2                             ;Software delay routines
 1D2                             ;**************************************************************************************
 1D2                             ;
 1D2                             ;
 1D2                             ;
 1D2                             ;Delay of 1us.
 1D2                             ;
 1D2                             ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
 1D2                             ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
 1D2                             ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
 1D2                             ;
 1D2                             ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 1D2                             ;
 1D2                             ;Registers used s0
 1D2                             ;
 1D2  0000B           delay_1us: LOAD s0, delay_1us_constant[0B]
 1D3  1C001            wait_1us: SUB s0, 01
 1D4  355D3                      JUMP NZ, wait_1us[1D3]
 1D5  2A000                      RETURN
 1D6                             ;
 1D6                             ;Delay of 40us.
 1D6                             ;
 1D6                             ;Registers used s0, s1
 1D6                             ;
 1D6  00128          delay_40us: LOAD s1, 28                             ;40 x 1us = 40us
 1D7  301D2           wait_40us: CALL delay_1us[1D2]
 1D8  1C101                      SUB s1, 01
 1D9  355D7                      JUMP NZ, wait_40us[1D7]
 1DA  2A000                      RETURN
 1DB                             ;
 1DB                             ;
 1DB                             ;Delay of 1ms.
 1DB                             ;
 1DB                             ;Registers used s0, s1, s2
 1DB                             ;
 1DB  00219           delay_1ms: LOAD s2, 19                             ;25 x 40us = 1ms
 1DC  301D6            wait_1ms: CALL delay_40us[1D6]
 1DD  1C201                      SUB s2, 01
 1DE  355DC                      JUMP NZ, wait_1ms[1DC]
 1DF  2A000                      RETURN
 1E0                             ;
 1E0                             ;Delay of 20ms.
 1E0                             ;
 1E0                             ;Delay of 20ms used during initialisation.
 1E0                             ;
 1E0                             ;Registers used s0, s1, s2, s3
 1E0                             ;
 1E0  00314          delay_20ms: LOAD s3, 14                             ;20 x 1ms = 20ms
 1E1  301DB           wait_20ms: CALL delay_1ms[1DB]
 1E2  1C301                      SUB s3, 01
 1E3  355E1                      JUMP NZ, wait_20ms[1E1]
 1E4  2A000                      RETURN
 1E5                             ;
 1E5                             ;Delay of approximately 1 second.
 1E5                             ;
 1E5                             ;Registers used s0, s1, s2, s3, s4
 1E5                             ;
 1E5  00432            delay_1s: LOAD s4, 32                             ;50 x 20ms = 1000ms
 1E6  301E0             wait_1s: CALL delay_20ms[1E0]
 1E7  1C401                      SUB s4, 01
 1E8  355E6                      JUMP NZ, wait_1s[1E6]
 1E9  2A000                      RETURN
 1EA                             ;
 1EA                             ;
 1EA                             ;
 1EA                             ;**************************************************************************************
 1EA                             ;LCD Character Module Routines
 1EA                             ;**************************************************************************************
 1EA                             ;
 1EA                             ;LCD module is a 16 character by 2 line display but all displays are very similar
 1EA                             ;The 4-wire data interface will be used (DB4 to DB7).
 1EA                             ;
 1EA                             ;The LCD modules are relatively slow and software delay loops are used to slow down
 1EA                             ;KCPSM3 adequately for the LCD to communicate. The delay routines are provided in
 1EA                             ;a different section (see above in this case).
 1EA                             ;
 1EA                             ;
 1EA                             ;Pulse LCD enable signal 'E' high for greater than 230ns (1us is used).
 1EA                             ;
 1EA                             ;Register s4 should define the current state of the LCD output port.
 1EA                             ;
 1EA                             ;Registers used s0, s4
 1EA                             ;
 1EA  0E401         LCD_pulse_E: XOR s4, LCD_E[01]                       ;E=1
 1EB  2C440                      OUTPUT s4, LCD_output_port[40]
 1EC  301D2                      CALL delay_1us[1D2]
 1ED  0E401                      XOR s4, LCD_E[01]                       ;E=0
 1EE  2C440                      OUTPUT s4, LCD_output_port[40]
 1EF  2A000                      RETURN
 1F0                             ;
 1F0                             ;Write 4-bit instruction to LCD display.
 1F0                             ;
 1F0                             ;The 4-bit instruction should be provided in the upper 4-bits of register s4.
 1F0                             ;Note that this routine does not release the master enable but as it is only
 1F0                             ;used during initialisation and as part of the 8-bit instruction write it
 1F0                             ;should be acceptable.
 1F0                             ;
 1F0                             ;Registers used s4
 1F0                             ;
 1F0  0A4F8     LCD_write_inst4: AND s4, F8                              ;Enable=1 RS=0 Instruction, RW=0 Write, E=0
 1F1  2C440                      OUTPUT s4, LCD_output_port[40]          ;set up RS and RW >40ns before enable pulse
 1F2  301EA                      CALL LCD_pulse_E[1EA]
 1F3  2A000                      RETURN
 1F4                             ;
 1F4                             ;
 1F4                             ;Write 8-bit instruction to LCD display.
 1F4                             ;
 1F4                             ;The 8-bit instruction should be provided in register s5.
 1F4                             ;Instructions are written using the following sequence
 1F4                             ; Upper nibble
 1F4                             ; wait >1us
 1F4                             ; Lower nibble
 1F4                             ; wait >40us
 1F4                             ;
 1F4                             ;Registers used s0, s1, s4, s5
 1F4                             ;
 1F4  01450     LCD_write_inst8: LOAD s4, s5
 1F5  0A4F0                      AND s4, F0                              ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 1F6  0C408                      OR s4, LCD_drive[08]                    ;Enable=1
 1F7  301F0                      CALL LCD_write_inst4[1F0]               ;write upper nibble
 1F8  301D2                      CALL delay_1us[1D2]                     ;wait >1us
 1F9  01450                      LOAD s4, s5                             ;select lower nibble with
 1FA  20407                      SL1 s4                                  ;Enable=1
 1FB  20406                      SL0 s4                                  ;RS=0 Instruction
 1FC  20406                      SL0 s4                                  ;RW=0 Write
 1FD  20406                      SL0 s4                                  ;E=0
 1FE  301F0                      CALL LCD_write_inst4[1F0]               ;write lower nibble
 1FF  301D6                      CALL delay_40us[1D6]                    ;wait >40us
 200  004F0                      LOAD s4, F0                             ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 201  2C440                      OUTPUT s4, LCD_output_port[40]          ;Release master enable
 202  2A000                      RETURN
 203                             ;
 203                             ;
 203                             ;
 203                             ;Write 8-bit data to LCD display.
 203                             ;
 203                             ;The 8-bit data should be provided in register s5.
 203                             ;Data bytes are written using the following sequence
 203                             ; Upper nibble
 203                             ; wait >1us
 203                             ; Lower nibble
 203                             ; wait >40us
 203                             ;
 203                             ;Registers used s0, s1, s4, s5
 203                             ;
 203  01450      LCD_write_data: LOAD s4, s5
 204  0A4F0                      AND s4, F0                              ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 205  0C40C                      OR s4, 0C                               ;Enable=1 RS=1 Data, RW=0 Write, E=0
 206  2C440                      OUTPUT s4, LCD_output_port[40]          ;set up RS and RW >40ns before enable pulse
 207  301EA                      CALL LCD_pulse_E[1EA]                   ;write upper nibble
 208  301D2                      CALL delay_1us[1D2]                     ;wait >1us
 209  01450                      LOAD s4, s5                             ;select lower nibble with
 20A  20407                      SL1 s4                                  ;Enable=1
 20B  20407                      SL1 s4                                  ;RS=1 Data
 20C  20406                      SL0 s4                                  ;RW=0 Write
 20D  20406                      SL0 s4                                  ;E=0
 20E  2C440                      OUTPUT s4, LCD_output_port[40]          ;set up RS and RW >40ns before enable pulse
 20F  301EA                      CALL LCD_pulse_E[1EA]                   ;write lower nibble
 210  301D6                      CALL delay_40us[1D6]                    ;wait >40us
 211  004F0                      LOAD s4, F0                             ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 212  2C440                      OUTPUT s4, LCD_output_port[40]          ;Release master enable
 213  2A000                      RETURN
 214                             ;
 214                             ;
 214                             ;
 214                             ;
 214                             ;Read 8-bit data from LCD display.
 214                             ;
 214                             ;The 8-bit data will be read from the current LCD memory address
 214                             ;and will be returned in register s5.
 214                             ;It is advisable to set the LCD address (cursor position) before
 214                             ;using the data read for the first time otherwise the display may
 214                             ;generate invalid data on the first read.
 214                             ;
 214                             ;Data bytes are read using the following sequence
 214                             ; Upper nibble
 214                             ; wait >1us
 214                             ; Lower nibble
 214                             ; wait >40us
 214                             ;
 214                             ;Registers used s0, s1, s4, s5
 214                             ;
 214  0040E      LCD_read_data8: LOAD s4, 0E                             ;Enable=1 RS=1 Data, RW=1 Read, E=0
 215  2C440                      OUTPUT s4, LCD_output_port[40]          ;set up RS and RW >40ns before enable pulse
 216  0E401                      XOR s4, LCD_E[01]                       ;E=1
 217  2C440                      OUTPUT s4, LCD_output_port[40]
 218  301D2                      CALL delay_1us[1D2]                     ;wait >260ns to access data
 219  04502                      INPUT s5, LCD_input_port[02]            ;read upper nibble
 21A  0E401                      XOR s4, LCD_E[01]                       ;E=0
 21B  2C440                      OUTPUT s4, LCD_output_port[40]
 21C  301D2                      CALL delay_1us[1D2]                     ;wait >1us
 21D  0E401                      XOR s4, LCD_E[01]                       ;E=1
 21E  2C440                      OUTPUT s4, LCD_output_port[40]
 21F  301D2                      CALL delay_1us[1D2]                     ;wait >260ns to access data
 220  04002                      INPUT s0, LCD_input_port[02]            ;read lower nibble
 221  0E401                      XOR s4, LCD_E[01]                       ;E=0
 222  2C440                      OUTPUT s4, LCD_output_port[40]
 223  0A5F0                      AND s5, F0                              ;merge upper and lower nibbles
 224  2000E                      SR0 s0
 225  2000E                      SR0 s0
 226  2000E                      SR0 s0
 227  2000E                      SR0 s0
 228  0D500                      OR s5, s0
 229  00404                      LOAD s4, 04                             ;Enable=0 RS=1 Data, RW=0 Write, E=0
 22A  2C440                      OUTPUT s4, LCD_output_port[40]          ;Stop reading 5V device and release master enable
 22B  301D6                      CALL delay_40us[1D6]                    ;wait >40us
 22C  2A000                      RETURN
 22D                             ;
 22D                             ;
 22D                             ;Reset and initialise display to communicate using 4-bit data mode
 22D                             ;Includes routine to clear the display.
 22D                             ;
 22D                             ;Requires the 4-bit instructions 3,3,3,2 to be sent with suitable delays
 22D                             ;following by the 8-bit instructions to set up the display.
 22D                             ;
 22D                             ;  28 = '001' Function set, '0' 4-bit mode, '1' 2-line, '0' 5x7 dot matrix, 'xx'
 22D                             ;  06 = '000001' Entry mode, '1' increment, '0' no display shift
 22D                             ;  0C = '00001' Display control, '1' display on, '0' cursor off, '0' cursor blink off
 22D                             ;  01 = '00000001' Display clear
 22D                             ;
 22D                             ;Registers used s0, s1, s2, s3, s4
 22D                             ;
 22D  301E0           LCD_reset: CALL delay_20ms[1E0]                    ;wait more that 15ms for display to be ready
 22E  00430                      LOAD s4, 30
 22F  301F0                      CALL LCD_write_inst4[1F0]               ;send '3'
 230  301E0                      CALL delay_20ms[1E0]                    ;wait >4.1ms
 231  301F0                      CALL LCD_write_inst4[1F0]               ;send '3'
 232  301DB                      CALL delay_1ms[1DB]                     ;wait >100us
 233  301F0                      CALL LCD_write_inst4[1F0]               ;send '3'
 234  301D6                      CALL delay_40us[1D6]                    ;wait >40us
 235  00420                      LOAD s4, 20
 236  301F0                      CALL LCD_write_inst4[1F0]               ;send '2'
 237  301D6                      CALL delay_40us[1D6]                    ;wait >40us
 238  00528                      LOAD s5, 28                             ;Function set
 239  301F4                      CALL LCD_write_inst8[1F4]
 23A  00506                      LOAD s5, 06                             ;Entry mode
 23B  301F4                      CALL LCD_write_inst8[1F4]
 23C  0050C                      LOAD s5, 0C                             ;Display control
 23D  301F4                      CALL LCD_write_inst8[1F4]
 23E  00501           LCD_clear: LOAD s5, 01                             ;Display clear
 23F  301F4                      CALL LCD_write_inst8[1F4]
 240  301DB                      CALL delay_1ms[1DB]                     ;wait >1.64ms for display to clear
 241  301DB                      CALL delay_1ms[1DB]
 242  2A000                      RETURN
 243                             ;
 243                             ;Position the cursor ready for characters to be written.
 243                             ;The display is formed of 2 lines of 16 characters and each
 243                             ;position has a corresponding address as indicated below.
 243                             ;
 243                             ;                   Character position
 243                             ;           0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
 243                             ;
 243                             ; Line 1 - 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F
 243                             ; Line 2 - C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF
 243                             ;
 243                             ;This routine will set the cursor position using the value provided
 243                             ;in register s5. The upper nibble will define the line and the lower
 243                             ;nibble the character position on the line.
 243                             ; Example s5 = 2B will position the cursor on line 2 position 11
 243                             ;
 243                             ;Registers used s0, s1, s2, s3, s4
 243                             ;
 243  12510          LCD_cursor: TEST s5, 10                             ;test for line 1
 244  35249                      JUMP Z, set_line2[249]
 245  0A50F                      AND s5, 0F                              ;make address in range 80 to 8F for line 1
 246  0C580                      OR s5, 80
 247  301F4                      CALL LCD_write_inst8[1F4]               ;instruction write to set cursor
 248  2A000                      RETURN
 249  0A50F           set_line2: AND s5, 0F                              ;make address in range C0 to CF for line 2
 24A  0C5C0                      OR s5, C0
 24B  301F4                      CALL LCD_write_inst8[1F4]               ;instruction write to set cursor
 24C  2A000                      RETURN
 24D                             ;
 24D                             ;
 24D                             ;**************************************************************************************
 24D                             ;Interrupt Service Routine (ISR)
 24D                             ;**************************************************************************************
 24D                             ;
 24D                             ;Interrupts occur at 1 second intervals.
 24D                             ;
 24D                             ;Each interrupt is used to take analogue samples and store them in scratch pad memory.
 24D                             ;The interrupt clears a 'flag' in register sF so that the main program can advance.
 24D                             ;
 24D  30145                 ISR: CALL adc_read[145]                      ;read A/D Converter
 24E  2E800                      STORE s8, ADC0_lsb[00]                  ;store ADC Channel 0
 24F  2E901                      STORE s9, ADC0_msb[01]
 250  2E602                      STORE s6, ADC1_lsb[02]                  ;store ADC Channel 1
 251  2E703                      STORE s7, ADC1_msb[03]
 252                             ;
 252  00F00                      LOAD sF, 00                             ;clear flag
 253  38001                      RETURNI ENABLE
 254                             ;
 254                             ;
 254                             ;**************************************************************************************
 254                             ;Interrupt Vector
 254                             ;**************************************************************************************
 254                             ;
 3FF                             ADDRESS 3FF
 3FF  3424D                      JUMP ISR[24D]
 3FF                             ;
 3FF                             ;
